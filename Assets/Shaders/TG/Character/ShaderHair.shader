Shader "TG/Character/RealHair"
{
    Properties
    {
        [NoScaleOffset]_DiffuseMap("Diffuse Map", 2D) = "white" {}
        _Diffuse_Tiling("Diffuse Tiling", Vector) = (1, 1, 0, 0)
        _Diffuse_Offset("Diffuse Offset", Vector) = (0, 0, 0, 0)
        _DiffuseColor("Diffuse Color", Color) = (1, 1, 1, 0)
        _DiffuseStrength("Diffuse Strength", Range(0, 2)) = 1
        _AlphaPower("Alpha Power", Range(0.01, 2)) = 1
        _AlphaRemap("Alpha Remap", Range(0.5, 1)) = 1
        _AlphaClip("Alpha Clip", Range(0, 1)) = 0.2
        _ShadowClip("Shadow Clip", Range(0, 1)) = 0.2
        _DepthPrepass("Depth Prepass", Range(0, 1)) = 0.95
        _DepthPostpass("Depth Postpass", Range(0, 1)) = 0.2
        [NoScaleOffset]_MaskMap("Mask Map", 2D) = "white" {}
        _AOStrength("Ambient Occlusion Strength", Range(0, 1)) = 1
        _AOOccludeAll("AO Occlude All", Range(0, 1)) = 0
        _SmoothnessPower("Smoothness Power", Range(0.5, 2)) = 1
        _SmoothnessMin("Smoothness Min", Range(0, 1)) = 0
        _SmoothnessMax("Smoothness Max", Range(0, 1)) = 0.8
        _SecondarySmoothness("Secondary Smoothness", Range(0, 1)) = 0.625
        [Normal][NoScaleOffset]_NormalMap("Normal Map", 2D) = "bump" {}
        _NormalStrength("Normal Strength", Float) = 1
        [NoScaleOffset]_BlendMap("Blend Map", 2D) = "white" {}
        _BlendStrength("Blend Strength", Range(0, 1)) = 1
        [NoScaleOffset]_FlowMap("Flow Map", 2D) = "grey" {}
        _FlowMapFlipGreen("Flow Map Flip Green", Range(0, 1)) = 0
        [NoScaleOffset]_SpecularMap("Specular Map", 2D) = "white" {}
        _SpecularTint("Specular Tint", Color) = (1, 1, 1, 1)
        _SpecularMultiplier("Specular Multiplier", Range(0, 1)) = 0.5
        _SpecularShiftMin("Specular Shift Min", Range(-1, 1)) = 0
        _SpecularShiftMax("Specular Shift Max", Range(-1, 1)) = 0
        _SecondarySpecularMultiplier("Secondary Specular Multiplier", Range(0, 1)) = 0.05
        _SecondarySpecularShift("Secondary Specular Shift", Range(-1, 1)) = 0.15
        _RimTransmissionIntensity("Rim Transmission Intensity", Range(0, 1)) = 0.05
        [NoScaleOffset]_EmissionMap("Emission Map", 2D) = "white" {}
        [HDR]_EmissiveColor("Emissive Color", Color) = (0, 0, 0, 0)
        [NoScaleOffset]_RootMap("Root Map", 2D) = "grey" {}
        _BaseColorStrength("Base Color Strength", Range(0, 1)) = 1
        _GlobalStrength("Global Strength", Range(0, 1)) = 1
        _RootColorStrength("Root Color Strength", Range(0, 1)) = 1
        _EndColorStrength("End Color Strength", Range(0, 1)) = 1
        _InvertRootMap("Invert Root Map", Range(0, 1)) = 0
        _RootColor("Root Color", Color) = (0.3294118, 0.1411765, 0.05098039, 0)
        _EndColor("End Color", Color) = (0.6039216, 0.454902, 0.2862745, 0)
        [NoScaleOffset]_IDMap("ID Map", 2D) = "grey" {}
        _HighlightBlend("Highlight Blend", Range(0, 1)) = 1
        _HighlightAStrength("Highlight A Strength", Range(0, 1)) = 1
        _HighlightAColor("Highlight A Color", Color) = (0.9137255, 0.7803922, 0.6352941, 0)
        _HighlightADistribution("Highlight A Distribution", Vector) = (0.1, 0.2, 0.3, 0)
        _HighlightAOverlapEnd("Highlight A Overlap End", Range(0, 1)) = 1
        _HighlightAOverlapInvert("Highlight A Overlap Invert", Range(0, 1)) = 1
        _HighlightBStrength("Highlight B Strength", Range(0, 1)) = 0
        _HighlightBColor("Highlight B Color", Color) = (1, 1, 1, 0)
        _HighlightBDistribution("Highlight B Distribution", Vector) = (0.6, 0.7, 0.8, 0)
        _HighlightBOverlapEnd("Highlight B Overlap End", Range(0, 1)) = 1
        _HighlightBOverlapInvert("Highlight B Overlap Invert", Range(0, 1)) = 1
        _TransmittanceMultiplier("TransmittanceMultiplier", Range(0, 1)) = 0.33
        [HideInInspector]_InstanceData("Instance data", Vector) = (0, 0, 0, 0)
        [HideInInspector]_EmissionColor("Color", Color) = (1, 1, 1, 1)
        [HideInInspector]_RenderQueueType("Float", Float) = 4
        [HideInInspector][ToggleUI]_AddPrecomputedVelocity("Boolean", Float) = 0
        [HideInInspector][ToggleUI]_DepthOffsetEnable("Boolean", Float) = 0
        [HideInInspector][ToggleUI]_ConservativeDepthOffsetEnable("Boolean", Float) = 0
        [HideInInspector][ToggleUI]_TransparentWritingMotionVec("Boolean", Float) = 1
        [HideInInspector][ToggleUI]_AlphaCutoffEnable("Boolean", Float) = 1
        [HideInInspector]_TransparentSortPriority("_TransparentSortPriority", Float) = 0
        [HideInInspector][ToggleUI]_UseShadowThreshold("Boolean", Float) = 1
        [HideInInspector][ToggleUI]_DoubleSidedEnable("Boolean", Float) = 1
        [HideInInspector][Enum(Flip, 0, Mirror, 1, None, 2)]_DoubleSidedNormalMode("Float", Float) = 2
        [HideInInspector]_DoubleSidedConstants("Vector4", Vector) = (1, 1, -1, 0)
        [HideInInspector][Enum(Auto, 0, On, 1, Off, 2)]_DoubleSidedGIMode("Float", Float) = 0
        [HideInInspector][ToggleUI]_TransparentDepthPrepassEnable("Boolean", Float) = 1
        [HideInInspector][ToggleUI]_TransparentDepthPostpassEnable("Boolean", Float) = 1
        [HideInInspector][ToggleUI]_PerPixelSorting("Boolean", Float) = 0
        [HideInInspector]_SurfaceType("Float", Float) = 1
        [HideInInspector]_BlendMode("Float", Float) = 0
        [HideInInspector]_SrcBlend("Float", Float) = 1
        [HideInInspector]_DstBlend("Float", Float) = 0
        [HideInInspector]_DstBlend2("Float", Float) = 0
        [HideInInspector]_AlphaSrcBlend("Float", Float) = 1
        [HideInInspector]_AlphaDstBlend("Float", Float) = 0
        [HideInInspector][ToggleUI]_ZWrite("Boolean", Float) = 0
        [HideInInspector][ToggleUI]_TransparentZWrite("Boolean", Float) = 0
        [HideInInspector]_CullMode("Float", Float) = 2
        [HideInInspector][ToggleUI]_EnableFogOnTransparent("Boolean", Float) = 1
        [HideInInspector]_CullModeForward("Float", Float) = 2
        [HideInInspector][Enum(Front, 1, Back, 2)]_TransparentCullMode("Float", Float) = 2
        [HideInInspector][Enum(UnityEngine.Rendering.HighDefinition.OpaqueCullMode)]_OpaqueCullMode("Float", Float) = 2
        [HideInInspector]_ZTestDepthEqualForOpaque("Float", Int) = 4
        [HideInInspector][Enum(UnityEngine.Rendering.CompareFunction)]_ZTestTransparent("Float", Float) = 4
        [HideInInspector][ToggleUI]_TransparentBackfaceEnable("Boolean", Float) = 1
        [HideInInspector][ToggleUI]_RequireSplitLighting("Boolean", Float) = 0
        [HideInInspector][ToggleUI]_ReceivesSSR("Boolean", Float) = 1
        [HideInInspector][ToggleUI]_ReceivesSSRTransparent("Boolean", Float) = 0
        [HideInInspector][ToggleUI]_EnableBlendModePreserveSpecularLighting("Boolean", Float) = 0
        [HideInInspector][ToggleUI]_SupportDecals("Boolean", Float) = 1
        [HideInInspector][ToggleUI]_ExcludeFromTUAndAA("Boolean", Float) = 0
        [HideInInspector]_StencilRef("Float", Int) = 0
        [HideInInspector]_StencilWriteMask("Float", Int) = 6
        [HideInInspector]_StencilRefDepth("Float", Int) = 0
        [HideInInspector]_StencilWriteMaskDepth("Float", Int) = 9
        [HideInInspector]_StencilRefMV("Float", Int) = 32
        [HideInInspector]_StencilWriteMaskMV("Float", Int) = 43
        [HideInInspector]_StencilRefDistortionVec("Float", Int) = 4
        [HideInInspector]_StencilWriteMaskDistortionVec("Float", Int) = 4
        [HideInInspector][NoScaleOffset]unity_Lightmaps("unity_Lightmaps", 2DArray) = "" {}
        [HideInInspector][NoScaleOffset]unity_LightmapsInd("unity_LightmapsInd", 2DArray) = "" {}
        [HideInInspector][NoScaleOffset]unity_ShadowMasks("unity_ShadowMasks", 2DArray) = "" {}
    }
    SubShader
    {
        Tags
        {
            "RenderPipeline"="HDRenderPipeline"
            "RenderType"="HDLitShader"
            "Queue"="Transparent+0"
            "DisableBatching"="False"
            "ShaderGraphShader"="true"
            "ShaderGraphTargetId"="HairSubTarget"
        }
        Pass
        {
            Name "ShadowCaster"
            Tags
            {
                "LightMode" = "ShadowCaster"
            }
        
            // Render State
            Cull [_CullMode]
        ZWrite On
        ColorMask 0
        ZClip [_ZClip]
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature_local _ _DOUBLESIDED_ON
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_SHADOWS
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_TEXCOORD0
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0 : INTERP0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.texCoord0.xyzw = input.texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.texCoord0 = input.texCoord0.xyzw;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdShadow;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.texCoord0 =                  input.texCoord0;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
        
        
        \
        
        
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    alphaCutoff = _UseShadowThreshold ? surfaceDescription.AlphaClipThresholdShadow : alphaCutoff;
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "META"
            Tags
            {
                "LightMode" = "META"
            }
        
            // Render State
            Cull Off
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature _ EDITOR_VISUALIZATION
        #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local_fragment _ _ENABLE_FOG_ON_TRANSPARENT
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
            // GraphKeywords: <None>
        
            // Defines
            #define SHADERPASS SHADERPASS_LIGHT_TRANSPORT
        #define RAYTRACING_SHADER_GRAPH_DEFAULT
        #define SCENEPICKINGPASS 1
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorPreInclude' */
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_TEXCOORD1
            #define ATTRIBUTES_NEED_TEXCOORD2
            #define ATTRIBUTES_NEED_TEXCOORD3
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_POSITIONPREDISPLACEMENT_WS
            #define VARYINGS_NEED_TEXCOORD0
            #define VARYINGS_NEED_TEXCOORD1
            #define VARYINGS_NEED_TEXCOORD2
            #define VARYINGS_NEED_TEXCOORD3
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
            #define FRAG_INPUTS_USE_TEXCOORD1
            #define FRAG_INPUTS_USE_TEXCOORD2
            #define FRAG_INPUTS_USE_TEXCOORD3
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 uv0 : TEXCOORD0;
             float4 uv1 : TEXCOORD1;
             float4 uv2 : TEXCOORD2;
             float4 uv3 : TEXCOORD3;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float3 positionRWS;
             float3 positionPredisplacementRWS;
             float4 texCoord0;
             float4 texCoord1;
             float4 texCoord2;
             float4 texCoord3;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0 : INTERP0;
             float4 texCoord1 : INTERP1;
             float4 texCoord2 : INTERP2;
             float4 texCoord3 : INTERP3;
             float3 positionRWS : INTERP4;
             float3 positionPredisplacementRWS : INTERP5;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.texCoord0.xyzw = input.texCoord0;
            output.texCoord1.xyzw = input.texCoord1;
            output.texCoord2.xyzw = input.texCoord2;
            output.texCoord3.xyzw = input.texCoord3;
            output.positionRWS.xyz = input.positionRWS;
            output.positionPredisplacementRWS.xyz = input.positionPredisplacementRWS;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.texCoord0 = input.texCoord0.xyzw;
            output.texCoord1 = input.texCoord1.xyzw;
            output.texCoord2 = input.texCoord2.xyzw;
            output.texCoord3 = input.texCoord3.xyzw;
            output.positionRWS = input.positionRWS.xyz;
            output.positionPredisplacementRWS = input.positionPredisplacementRWS.xyz;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            struct VertexDescription
        {
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorVertMeshCustomInterpolation' */
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.positionRWS =                input.positionRWS;
            output.positionPredisplacementRWS = input.positionPredisplacementRWS;
            output.texCoord0 =                  input.texCoord0;
            output.texCoord1 =                  input.texCoord1;
            output.texCoord2 =                  input.texCoord2;
            output.texCoord3 =                  input.texCoord3;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorVaryingsToFragInputs' */
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorCopyToSDI' */
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassLightTransport.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "ScenePickingPass"
            Tags
            {
                "LightMode" = "Picking"
            }
        
            // Render State
            Cull [_CullMode]
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma editor_sync_compilation
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_DEPTH_ONLY
        #define SCENEPICKINGPASS 1
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float3 normalWS;
             float4 tangentWS;
             float4 texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 tangentWS : INTERP0;
             float4 texCoord0 : INTERP1;
             float3 normalWS : INTERP2;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.tangentWS.xyzw = input.tangentWS;
            output.texCoord0.xyzw = input.texCoord0;
            output.normalWS.xyz = input.normalWS;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.tangentWS = input.tangentWS.xyzw;
            output.texCoord0 = input.texCoord0.xyzw;
            output.normalWS = input.normalWS.xyz;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.tangentToWorld =             BuildTangentToWorld(input.tangentWS, input.normalWS);
            output.texCoord0 =                  input.texCoord0;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "SceneSelectionPass"
            Tags
            {
                "LightMode" = "SceneSelectionPass"
            }
        
            // Render State
            Cull Off
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma editor_sync_compilation
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_DEPTH_ONLY
        #define RAYTRACING_SHADER_GRAPH_DEFAULT
        #define SCENESELECTIONPASS 1
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_TEXCOORD0
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/PickingSpaceTransforms.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0 : INTERP0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.texCoord0.xyzw = input.texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.texCoord0 = input.texCoord0.xyzw;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.texCoord0 =                  input.texCoord0;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "MotionVectors"
            Tags
            {
                "LightMode" = "MotionVectors"
            }
        
            // Render State
            Cull [_CullMode]
        ZWrite On
        Stencil
        {
        WriteMask [_StencilWriteMaskMV]
        Ref [_StencilRefMV]
        CompFront Always
        PassFront Replace
        CompBack Always
        PassBack Replace
        }
        AlphaToMask [_AlphaCutoffEnable]
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma multi_compile_fragment _ WRITE_MSAA_DEPTH
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
        #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC _TRANSPARENT_REFRACTIVE_SORT
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
        #pragma multi_compile_fragment _ WRITE_DECAL_BUFFER_AND_RENDERING_LAYER
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_MOTION_VECTORS
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        #define WRITE_NORMAL_BUFFER 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float3 positionRWS;
             float3 normalWS;
             float4 tangentWS;
             float4 texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 tangentWS : INTERP0;
             float4 texCoord0 : INTERP1;
             float3 positionRWS : INTERP2;
             float3 normalWS : INTERP3;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.tangentWS.xyzw = input.tangentWS;
            output.texCoord0.xyzw = input.texCoord0;
            output.positionRWS.xyz = input.positionRWS;
            output.normalWS.xyz = input.normalWS;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.tangentWS = input.tangentWS.xyzw;
            output.texCoord0 = input.texCoord0.xyzw;
            output.positionRWS = input.positionRWS.xyz;
            output.normalWS = input.normalWS.xyz;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.positionRWS =                input.positionRWS;
            output.tangentToWorld =             BuildTangentToWorld(input.tangentWS, input.normalWS);
            output.texCoord0 =                  input.texCoord0;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassMotionVectors.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "TransparentBackface"
            Tags
            {
                "LightMode" = "TransparentBackface"
            }
        
            // Render State
            Cull Front
        Blend [_SrcBlend] [_DstBlend], [_AlphaSrcBlend] [_AlphaDstBlend]
        Blend 1 One OneMinusSrcAlpha
        Blend 2 One OneMinusSrcAlpha
        Blend 3 One OneMinusSrcAlpha
        Blend 4 One OneMinusSrcAlpha
        ZTest [_ZTestTransparent]
        ZWrite [_ZWrite]
        ColorMask [_ColorMaskTransparentVelOne] 1
        ColorMask [_ColorMaskTransparentVelTwo] 2
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
        #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC _TRANSPARENT_REFRACTIVE_SORT
        #pragma shader_feature_local_fragment _ _ENABLE_FOG_ON_TRANSPARENT
        #pragma multi_compile _ DEBUG_DISPLAY
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
        #pragma shader_feature_local_fragment _ _DISABLE_SSR
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR
        #pragma shader_feature_local_fragment _ _DISABLE_SSR_TRANSPARENT
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR_TRANSPARENT
        #pragma multi_compile _ LIGHTMAP_ON
        #pragma multi_compile _ DIRLIGHTMAP_COMBINED
        #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile_raytracing _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile _ DYNAMICLIGHTMAP_ON
        #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK
        #pragma multi_compile_raytracing _ SHADOWS_SHADOWMASK
        #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT
        #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT
        #pragma multi_compile _ USE_LEGACY_LIGHTMAPS
        #pragma multi_compile_fragment PUNCTUAL_SHADOW_LOW PUNCTUAL_SHADOW_MEDIUM PUNCTUAL_SHADOW_HIGH
        #pragma multi_compile_fragment DIRECTIONAL_SHADOW_LOW DIRECTIONAL_SHADOW_MEDIUM DIRECTIONAL_SHADOW_HIGH
        #pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH
        #pragma multi_compile_fragment SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_FORWARD
        #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1
        #define HAS_LIGHTLOOP 1
        #define RAYTRACING_SHADER_GRAPH_DEFAULT
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        #define USE_CLUSTERED_LIGHTLIST
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_TEXCOORD1
            #define ATTRIBUTES_NEED_TEXCOORD2
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
            #define VARYINGS_NEED_TEXCOORD1
            #define VARYINGS_NEED_TEXCOORD2
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
            #define FRAG_INPUTS_USE_TEXCOORD1
            #define FRAG_INPUTS_USE_TEXCOORD2
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
             float4 uv1 : TEXCOORD1;
             float4 uv2 : TEXCOORD2;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float3 positionRWS;
             float3 normalWS;
             float4 tangentWS;
             float4 texCoord0;
             float4 texCoord1;
             float4 texCoord2;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 tangentWS : INTERP0;
             float4 texCoord0 : INTERP1;
             float4 texCoord1 : INTERP2;
             float4 texCoord2 : INTERP3;
             float3 positionRWS : INTERP4;
             float3 normalWS : INTERP5;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.tangentWS.xyzw = input.tangentWS;
            output.texCoord0.xyzw = input.texCoord0;
            output.texCoord1.xyzw = input.texCoord1;
            output.texCoord2.xyzw = input.texCoord2;
            output.positionRWS.xyz = input.positionRWS;
            output.normalWS.xyz = input.normalWS;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.tangentWS = input.tangentWS.xyzw;
            output.texCoord0 = input.texCoord0.xyzw;
            output.texCoord1 = input.texCoord1.xyzw;
            output.texCoord2 = input.texCoord2.xyzw;
            output.positionRWS = input.positionRWS.xyz;
            output.normalWS = input.normalWS.xyz;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
            float4 VTPackedFeedback;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            {
                surface.VTPackedFeedback = float4(1.0f,1.0f,1.0f,1.0f);
            }
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.positionRWS =                input.positionRWS;
            output.tangentToWorld =             BuildTangentToWorld(input.tangentWS, input.normalWS);
            output.texCoord0 =                  input.texCoord0;
            output.texCoord1 =                  input.texCoord1;
            output.texCoord2 =                  input.texCoord2;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "TransparentDepthPostpass"
            Tags
            {
                "LightMode" = "TransparentDepthPostpass"
            }
        
            // Render State
            Cull [_CullMode]
        Blend One Zero
        ZWrite On
        ColorMask 0
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC _TRANSPARENT_REFRACTIVE_SORT
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
        #define RAYTRACING_SHADER_GRAPH_DEFAULT
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_TEXCOORD0
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0 : INTERP0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.texCoord0.xyzw = input.texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.texCoord0 = input.texCoord0.xyzw;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float Alpha;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThreshold;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.texCoord0 =                  input.texCoord0;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
        
        
        \
        
        
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "TransparentDepthPrepass"
            Tags
            {
                "LightMode" = "TransparentDepthPrepass"
            }
        
            // Render State
            Cull [_CullMode]
        Blend One Zero
        ZWrite On
        Stencil
        {
        WriteMask [_StencilWriteMaskDepth]
        Ref [_StencilRefDepth]
        CompFront Always
        PassFront Replace
        CompBack Always
        PassBack Replace
        }
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC _TRANSPARENT_REFRACTIVE_SORT
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_TRANSPARENT_DEPTH_PREPASS
        #define RAYTRACING_SHADER_GRAPH_DEFAULT
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float3 normalWS;
             float4 tangentWS;
             float4 texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 tangentWS : INTERP0;
             float4 texCoord0 : INTERP1;
             float3 normalWS : INTERP2;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.tangentWS.xyzw = input.tangentWS;
            output.texCoord0.xyzw = input.texCoord0;
            output.normalWS.xyz = input.normalWS;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.tangentWS = input.tangentWS.xyzw;
            output.texCoord0 = input.texCoord0.xyzw;
            output.normalWS = input.normalWS.xyz;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float Alpha;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThreshold;
            float3 NormalTS;
            float Smoothness;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.tangentToWorld =             BuildTangentToWorld(input.tangentWS, input.normalWS);
            output.texCoord0 =                  input.texCoord0;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
        
        
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPrepass;
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "DepthForwardOnly"
            Tags
            {
                "LightMode" = "DepthForwardOnly"
            }
        
            // Render State
            Cull [_CullMode]
        ZWrite On
        Stencil
        {
        WriteMask [_StencilWriteMaskDepth]
        Ref [_StencilRefDepth]
        CompFront Always
        PassFront Replace
        CompBack Always
        PassBack Replace
        }
        AlphaToMask [_AlphaCutoffEnable]
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma multi_compile_fragment _ WRITE_MSAA_DEPTH
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
        #pragma multi_compile_fragment _ WRITE_DECAL_BUFFER WRITE_RENDERING_LAYER
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_DEPTH_ONLY
        #define RAYTRACING_SHADER_GRAPH_DEFAULT
        #define WRITE_NORMAL_BUFFER 1
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float3 positionRWS;
             float3 normalWS;
             float4 tangentWS;
             float4 texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 tangentWS : INTERP0;
             float4 texCoord0 : INTERP1;
             float3 positionRWS : INTERP2;
             float3 normalWS : INTERP3;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.tangentWS.xyzw = input.tangentWS;
            output.texCoord0.xyzw = input.texCoord0;
            output.positionRWS.xyz = input.positionRWS;
            output.normalWS.xyz = input.normalWS;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.tangentWS = input.tangentWS.xyzw;
            output.texCoord0 = input.texCoord0.xyzw;
            output.positionRWS = input.positionRWS.xyz;
            output.normalWS = input.normalWS.xyz;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.positionRWS =                input.positionRWS;
            output.tangentToWorld =             BuildTangentToWorld(input.tangentWS, input.normalWS);
            output.texCoord0 =                  input.texCoord0;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassDepthOnly.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "ForwardOnly"
            Tags
            {
                "LightMode" = "ForwardOnly"
            }
        
            // Render State
            Cull [_CullModeForward]
        Blend [_SrcBlend] [_DstBlend], [_AlphaSrcBlend] [_AlphaDstBlend]
        Blend 1 One OneMinusSrcAlpha
        Blend 2 One [_DstBlend2]
        Blend 3 One [_DstBlend2]
        Blend 4 One OneMinusSrcAlpha
        ZTest [_ZTestDepthEqualForOpaque]
        ZWrite [_ZWrite]
        ColorMask [_ColorMaskTransparentVelOne] 1
        ColorMask [_ColorMaskTransparentVelTwo] 2
        Stencil
        {
        WriteMask [_StencilWriteMask]
        Ref [_StencilRef]
        CompFront Always
        PassFront Replace
        CompBack Always
        PassBack Replace
        }
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local _ _ADD_PRECOMPUTED_VELOCITY
        #pragma shader_feature_local _ _TRANSPARENT_WRITES_MOTION_VEC _TRANSPARENT_REFRACTIVE_SORT
        #pragma shader_feature_local_fragment _ _ENABLE_FOG_ON_TRANSPARENT
        #pragma multi_compile _ DEBUG_DISPLAY
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
        #pragma shader_feature_local_fragment _ _DISABLE_SSR
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR
        #pragma shader_feature_local_fragment _ _DISABLE_SSR_TRANSPARENT
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR_TRANSPARENT
        #pragma multi_compile _ LIGHTMAP_ON
        #pragma multi_compile _ DIRLIGHTMAP_COMBINED
        #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile_raytracing _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile _ DYNAMICLIGHTMAP_ON
        #pragma multi_compile_fragment _ SHADOWS_SHADOWMASK
        #pragma multi_compile_raytracing _ SHADOWS_SHADOWMASK
        #pragma multi_compile_fragment DECALS_OFF DECALS_3RT DECALS_4RT
        #pragma multi_compile_fragment _ DECAL_SURFACE_GRADIENT
        #pragma multi_compile _ USE_LEGACY_LIGHTMAPS
        #pragma multi_compile_fragment PUNCTUAL_SHADOW_LOW PUNCTUAL_SHADOW_MEDIUM PUNCTUAL_SHADOW_HIGH
        #pragma multi_compile_fragment DIRECTIONAL_SHADOW_LOW DIRECTIONAL_SHADOW_MEDIUM DIRECTIONAL_SHADOW_HIGH
        #pragma multi_compile_fragment AREA_SHADOW_MEDIUM AREA_SHADOW_HIGH
        #pragma multi_compile_fragment SCREEN_SPACE_SHADOWS_OFF SCREEN_SPACE_SHADOWS_ON
        #pragma multi_compile_fragment USE_FPTL_LIGHTLIST USE_CLUSTERED_LIGHTLIST
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_FORWARD
        #define SUPPORT_BLENDMODE_PRESERVE_SPECULAR_LIGHTING 1
        #define HAS_LIGHTLOOP 1
        #define RAYTRACING_SHADER_GRAPH_DEFAULT
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_TEXCOORD1
            #define ATTRIBUTES_NEED_TEXCOORD2
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
            #define VARYINGS_NEED_TEXCOORD1
            #define VARYINGS_NEED_TEXCOORD2
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
            #define FRAG_INPUTS_USE_TEXCOORD1
            #define FRAG_INPUTS_USE_TEXCOORD2
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
             float4 uv1 : TEXCOORD1;
             float4 uv2 : TEXCOORD2;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float3 positionRWS;
             float3 normalWS;
             float4 tangentWS;
             float4 texCoord0;
             float4 texCoord1;
             float4 texCoord2;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 tangentWS : INTERP0;
             float4 texCoord0 : INTERP1;
             float4 texCoord1 : INTERP2;
             float4 texCoord2 : INTERP3;
             float3 positionRWS : INTERP4;
             float3 normalWS : INTERP5;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.tangentWS.xyzw = input.tangentWS;
            output.texCoord0.xyzw = input.texCoord0;
            output.texCoord1.xyzw = input.texCoord1;
            output.texCoord2.xyzw = input.texCoord2;
            output.positionRWS.xyz = input.positionRWS;
            output.normalWS.xyz = input.normalWS;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.tangentWS = input.tangentWS.xyzw;
            output.texCoord0 = input.texCoord0.xyzw;
            output.texCoord1 = input.texCoord1.xyzw;
            output.texCoord2 = input.texCoord2.xyzw;
            output.positionRWS = input.positionRWS.xyz;
            output.normalWS = input.normalWS.xyz;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
            float4 VTPackedFeedback;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            {
                surface.VTPackedFeedback = float4(1.0f,1.0f,1.0f,1.0f);
            }
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.positionRWS =                input.positionRWS;
            output.tangentToWorld =             BuildTangentToWorld(input.tangentWS, input.normalWS);
            output.texCoord0 =                  input.texCoord0;
            output.texCoord1 =                  input.texCoord1;
            output.texCoord2 =                  input.texCoord2;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                builtinData.vtPackedFeedback = surfaceDescription.VTPackedFeedback;
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassForward.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "FullScreenDebug"
            Tags
            {
                "LightMode" = "FullScreenDebug"
            }
        
            // Render State
            Cull [_CullMode]
        ZTest LEqual
        ZWrite Off
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma multi_compile _ DOTS_INSTANCING_ON
        #pragma instancing_options renderinglayer
        #pragma target 4.5
        #pragma vertex Vert
        #pragma fragment Frag
        #pragma only_renderers d3d11 playstation xboxone xboxseries vulkan metal switch
        #pragma multi_compile_instancing
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
            #pragma multi_compile_local _ KANDRA_SKINNING
        
        
        
            // Defines
            #define SHADERPASS SHADERPASS_FULL_SCREEN_DEBUG
        #define RAYTRACING_SHADER_GRAPH_DEFAULT
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            struct CustomInterpolators
        {
        };
        #define USE_CUSTOMINTERP_SUBSTRUCT
        
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_VERTEXID
            #define VARYINGS_NEED_TEXCOORD0
        
            #define HAVE_MESH_MODIFICATION
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Debug/DebugDisplay.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct AttributesMesh
        {
             float3 positionOS : POSITION;
             float3 normalOS : NORMAL;
             float4 tangentOS : TANGENT;
             float4 uv0 : TEXCOORD0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(ATTRIBUTES_NEED_INSTANCEID)
             uint instanceID : INSTANCEID_SEMANTIC;
            #endif
             uint vertexID : VERTEXID_SEMANTIC;
        };
        struct VaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        struct VertexDescriptionInputs
        {
             float3 ObjectSpaceNormal;
             float3 ObjectSpaceTangent;
             float3 ObjectSpacePosition;
             float4 uv0;
             uint VertexID;
        };
        struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        struct PackedVaryingsMeshToPS
        {
            SV_POSITION_QUALIFIERS float4 positionCS : SV_POSITION;
             float4 texCoord0 : INTERP0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
             uint instanceID : CUSTOM_INSTANCE_ID;
            #endif
        };
        
            PackedVaryingsMeshToPS PackVaryingsMeshToPS (VaryingsMeshToPS input)
        {
            PackedVaryingsMeshToPS output;
            ZERO_INITIALIZE(PackedVaryingsMeshToPS, output);
            output.positionCS = input.positionCS;
            output.texCoord0.xyzw = input.texCoord0;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        VaryingsMeshToPS UnpackVaryingsMeshToPS (PackedVaryingsMeshToPS input)
        {
            VaryingsMeshToPS output;
            output.positionCS = input.positionCS;
            output.texCoord0 = input.texCoord0.xyzw;
            #if UNITY_ANY_INSTANCING_ENABLED || defined(VARYINGS_NEED_INSTANCEID)
            output.instanceID = input.instanceID;
            #endif
            return output;
        }
        
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        // includeSampleSkinBuffer
        #include "Assets/Code/Kandra/ShaderGraphNodes/SampleSkinBuffer.hlsl"
        
        #ifndef PREVENT_REPEAT_SKIN_SAMPLE
        #define PREVENT_REPEAT_SKIN_SAMPLE
        void Sample_Skin_Buffer_float(uint vertexId, out float3 positionOut, out float3 normalOut, out float3 tangentOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        normalOut = 0;
        tangentOut = 0;
        sampleDeform(vertexId, instanceData, positionOut, normalOut, tangentOut);
        }
        #endif
        
        struct Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float
        {
        float3 ObjectSpaceNormal;
        float3 ObjectSpaceTangent;
        float3 ObjectSpacePosition;
        half4 uv0;
        uint VertexID;
        };
        
        void SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float IN, out float3 Position_1, out float3 Normal_2, out float3 Tangent_3)
        {
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = 0;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = 0;
        Sample_Skin_Buffer_float(IN.VertexID, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3, _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3);
        #else
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3 = IN.ObjectSpacePosition;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3 = IN.ObjectSpaceNormal;
        float3 _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3 = IN.ObjectSpaceTangent;
        #endif
        Position_1 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedPosition_0_Vector3;
        Normal_2 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedNormal_1_Vector3;
        Tangent_3 = _Sampleskinbuffer_23e5bcb6cf7d4fc598340cf9e8634601_DeformedTangent_2_Vector3;
        }
        
        #ifndef PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        #define PREVENT_REPEAT_PREVIOUS_POSITION_SAMPLE
        void Sample_Previous_Position_Buffer_float(uint vertexId, out float3 positionOut)
        {
        uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        positionOut = 0;
        SamplePreviousPosition(vertexId, instanceData, positionOut);
        }
        #endif
        
        void Unity_Subtract_float3(float3 A, float3 B, out float3 Out)
        {
            Out = A - B;
        }
        
        struct Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float
        {
        uint VertexID;
        };
        
        void SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(float3 _CurrentPosition, Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float IN, out float3 KandraVelocity_0)
        {
        float3 _Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3 = _CurrentPosition;
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        Sample_Previous_Position_Buffer_float(IN.VertexID, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3);
        #else
        float3 _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3 = 0;
        #endif
        float3 _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        Unity_Subtract_float3(_Property_7551edbe49b041df87e98dfe889ee2e0_Out_0_Vector3, _Kandrasamplepreviousposition_53ad94f9b3fc46f8a2ee62984441c581_PreviousPosition_0_Vector3, _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3);
        #if defined(KANDRA_SKINNING)
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = _Subtract_dd691e547bcc4f8fbc2b1eb48b55023a_Out_2_Vector3;
        #else
        float3 _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3 = float3(0, 0, 0);
        #endif
        KandraVelocity_0 = _KANDRASKINNING_e733d92bdc214d3d922fa04f2017cd05_Out_0_Vector3;
        }
        
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            struct VertexDescription
        {
            float3 Position;
            float3 Normal;
            float3 Tangent;
            float3 CustomVelocity;
        };
        
        VertexDescription VertexDescriptionFunction(VertexDescriptionInputs IN)
        {
            VertexDescription description = (VertexDescription)0;
            Bindings_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceNormal = IN.ObjectSpaceNormal;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpaceTangent = IN.ObjectSpaceTangent;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.ObjectSpacePosition = IN.ObjectSpacePosition;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.uv0 = IN.uv0;
            _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72.VertexID = IN.VertexID;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            float3 _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            SG_KandraVertexSubGraph_b893b756a94bbc24ea1c10938e20d1d2_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3, _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3);
            Bindings_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b;
            _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b.VertexID = IN.VertexID;
            float3 _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            SG_KandraVelocitySubGraph_1c0f9e832745ce14da01f179b148f56c_float(_KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b, _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3);
            description.Position = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Position_1_Vector3;
            description.Normal = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Normal_2_Vector3;
            description.Tangent = _KandraVertexSubGraph_87fa266fad1e4fc0b62ff940384bbd72_Tangent_3_Vector3;
            description.CustomVelocity = _KandraVelocitySubGraph_034c2112d2414be4a2e3f55243ab774b_KandraVelocity_0_Vector3;
            return description;
        }
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            
        VertexDescriptionInputs AttributesMeshToVertexDescriptionInputs(AttributesMesh input)
        {
            VertexDescriptionInputs output;
            ZERO_INITIALIZE(VertexDescriptionInputs, output);
        
            output.ObjectSpaceNormal =                          input.normalOS;
            output.ObjectSpaceTangent =                         input.tangentOS.xyz;
            output.ObjectSpacePosition =                        input.positionOS;
            output.uv0 =                                        input.uv0;
            output.VertexID =                                   input.vertexID;
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
            return output;
        }
        
        VertexDescription GetVertexDescription(AttributesMesh input, float3 timeParameters
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            // build graph inputs
            VertexDescriptionInputs vertexDescriptionInputs = AttributesMeshToVertexDescriptionInputs(input);
            // Override time parameters with used one (This is required to correctly handle motion vectors for vertex animation based on time)
        
            // evaluate vertex graph
        #ifdef HAVE_VFX_MODIFICATION
            GraphProperties properties;
            ZERO_INITIALIZE(GraphProperties, properties);
        
            // Fetch the vertex graph properties for the particle instance.
            GetElementVertexProperties(element, properties);
        
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs, properties);
        #else
            VertexDescription vertexDescription = VertexDescriptionFunction(vertexDescriptionInputs);
        #endif
            return vertexDescription;
        
        }
        
        #include "Assets/Code/Kandra/ShaderGraphNodes/KandraSkinBuffers.hlsl"
        
        AttributesMesh ApplyMeshModification(AttributesMesh input, float3 timeParameters
        #ifdef USE_CUSTOMINTERP_SUBSTRUCT
            #ifdef TESSELLATION_ON
            , inout VaryingsMeshToDS varyings
            #else
            , inout VaryingsMeshToPS varyings
            #endif
        #endif
        #ifdef HAVE_VFX_MODIFICATION
                , AttributesElement element
        #endif
            )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, timeParameters
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
        
            // copy graph output to the results
            input.positionOS = vertexDescription.Position;
            input.normalOS = vertexDescription.Normal;
            input.tangentOS.xyz = vertexDescription.Tangent;
        
        #if (defined(UNITY_DOTS_INSTANCING_ENABLED) && defined(KANDRA_SKINNING))
            uint2 instanceData = asuint(UNITY_ACCESS_HYBRID_INSTANCED_PROP(_InstanceData, float2));
        
            const AdditionalVertexData additionalVertexData = KANDRA_ADDITIONAL_VERTICES_BUFFER[input.vertexID + instanceData.y];
            input.uv0.x = f16tof32(additionalVertexData.uv & 0x0000FFFF);
            input.uv0.y = f16tof32(additionalVertexData.uv >> 16);
            input.tangentOS.w = additionalVertexData.tangentW;
        #endif
        
            
        
            return input;
        }
        
        #if defined(_ADD_CUSTOM_VELOCITY) // For shader graph custom velocity
        // Return precomputed Velocity in object space
        float3 GetCustomVelocity(AttributesMesh input
        #ifdef HAVE_VFX_MODIFICATION
            , AttributesElement element
        #endif
        )
        {
            VertexDescription vertexDescription = GetVertexDescription(input, _TimeParameters.xyz
        #ifdef HAVE_VFX_MODIFICATION
                , element
        #endif
            );
            return vertexDescription.CustomVelocity;
        }
        #endif
        
        FragInputs BuildFragInputs(VaryingsMeshToPS input)
        {
            FragInputs output;
            ZERO_INITIALIZE(FragInputs, output);
        
            // Init to some default value to make the computer quiet (else it output 'divide by zero' warning even if value is not used).
            // TODO: this is a really poor workaround, but the variable is used in a bunch of places
            // to compute normals which are then passed on elsewhere to compute other values...
            output.tangentToWorld = k_identity3x3;
            output.positionSS = input.positionCS;       // input.positionCS is SV_Position
        
            output.texCoord0 =                  input.texCoord0;
        
        #if UNITY_ANY_INSTANCING_ENABLED
        #else
        #endif
        
        #ifdef HAVE_VFX_MODIFICATION
            // FragInputs from VFX come from two places: Interpolator or CBuffer.
        #if VFX_USE_GRAPH_VALUES
            uint instanceActiveIndex = asuint(UNITY_ACCESS_INSTANCED_PROP(PerInstance, _InstanceActiveIndex));
            /* WARNING: $splice Could not find named fragment 'VFXLoadGraphValues' */
        #endif
        
            /* WARNING: $splice Could not find named fragment 'VFXSetFragInputs' */
        
        #endif
        
            // splice point to copy custom interpolator fields from varyings to frag inputs
            
        
            return output;
        }
        
        // existing HDRP code uses the combined function to go directly from packed to frag inputs
        FragInputs UnpackVaryingsMeshToFragInputs(PackedVaryingsMeshToPS input)
        {
            UNITY_SETUP_INSTANCE_ID(input);
        #if defined(HAVE_VFX_MODIFICATION) && defined(UNITY_INSTANCING_ENABLED)
            unity_InstanceID = input.instanceID;
        #endif
            VaryingsMeshToPS unpacked = UnpackVaryingsMeshToPS(input);
            return BuildFragInputs(unpacked);
        }
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassFullScreenDebug.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
    }
    SubShader
    {
        Tags
        {
            "RenderPipeline"="HDRenderPipeline"
            "RenderType"="HDLitShader"
            "Queue"="Transparent+0"
            "DisableBatching"="False"
            "ShaderGraphShader"="true"
            "ShaderGraphTargetId"="HairSubTarget"
        }
        Pass
        {
            Name "IndirectDXR"
            Tags
            {
                "LightMode" = "IndirectDXR"
            }
        
            // Render State
            // RenderState: <None>
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma target 5.0
        #pragma raytracing surface_shader
        #pragma only_renderers d3d11 xboxseries ps5
        
            // Keywords
            #pragma multi_compile _ MULTI_BOUNCE_INDIRECT
        #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma multi_compile _ DEBUG_DISPLAY
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
        #pragma shader_feature_local_fragment _ _DISABLE_SSR
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR
        #pragma shader_feature_local_fragment _ _DISABLE_SSR_TRANSPARENT
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR_TRANSPARENT
        #pragma multi_compile _ LIGHTMAP_ON
        #pragma multi_compile _ DIRLIGHTMAP_COMBINED
        #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile_raytracing _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile _ DYNAMICLIGHTMAP_ON
        #pragma multi_compile_raytracing DECALS_OFF DECALS_3RT DECALS_4RT
        #pragma multi_compile_raytracing _ DECAL_SURFACE_GRADIENT
            // GraphKeywords: <None>
        
            // Defines
            #define SHADERPASS SHADERPASS_RAYTRACING_INDIRECT
        #define PUNCTUAL_SHADOW_LOW
        #define DIRECTIONAL_SHADOW_LOW
        #define RAYTRACING_SHADER_GRAPH_RAYTRACED
        #define LIGHTLOOP_DISABLE_TILE_AND_CLUSTER 1
        #define PATH_TRACING_CLUSTERED_DECALS 1
        #define HAS_LIGHTLOOP 1
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorPreInclude' */
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_TEXCOORD1
            #define ATTRIBUTES_NEED_TEXCOORD2
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
            #define VARYINGS_NEED_TEXCOORD1
            #define VARYINGS_NEED_TEXCOORD2
        
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
            #define FRAG_INPUTS_USE_TEXCOORD1
            #define FRAG_INPUTS_USE_TEXCOORD2
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracingLightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/HairRayTracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingLightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        
            //Interpolator Packs: <None>
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            // GraphVertex: <None>
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorCopyToSDI' */
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassRaytracingIndirect.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "VisibilityDXR"
            Tags
            {
                "LightMode" = "VisibilityDXR"
            }
        
            // Render State
            // RenderState: <None>
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma target 5.0
        #pragma raytracing surface_shader
        #pragma only_renderers d3d11 xboxseries ps5
        
            // Keywords
            #pragma multi_compile _ TRANSPARENT_COLOR_SHADOW
        #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
            // GraphKeywords: <None>
        
            // Defines
            #define SHADERPASS SHADERPASS_RAYTRACING_VISIBILITY
        #define RAYTRACING_SHADER_GRAPH_RAYTRACED
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorPreInclude' */
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define VARYINGS_NEED_TEXCOORD0
        
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracingLightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/HairRayTracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        
            //Interpolator Packs: <None>
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            // GraphVertex: <None>
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorCopyToSDI' */
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    alphaCutoff = _UseShadowThreshold ? surfaceDescription.AlphaClipThresholdShadow : alphaCutoff;
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassRaytracingVisibility.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "ForwardDXR"
            Tags
            {
                "LightMode" = "ForwardDXR"
            }
        
            // Render State
            // RenderState: <None>
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma target 5.0
        #pragma raytracing surface_shader
        #pragma only_renderers d3d11 xboxseries ps5
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma multi_compile _ DEBUG_DISPLAY
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
        #pragma shader_feature_local_fragment _ _DISABLE_SSR
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR
        #pragma shader_feature_local_fragment _ _DISABLE_SSR_TRANSPARENT
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR_TRANSPARENT
        #pragma multi_compile _ LIGHTMAP_ON
        #pragma multi_compile _ DIRLIGHTMAP_COMBINED
        #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile_raytracing _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile _ DYNAMICLIGHTMAP_ON
            // GraphKeywords: <None>
        
            // Defines
            #define SHADERPASS SHADERPASS_RAYTRACING_FORWARD
        #define PUNCTUAL_SHADOW_LOW
        #define DIRECTIONAL_SHADOW_LOW
        #define RAYTRACING_SHADER_GRAPH_RAYTRACED
        #define HAS_LIGHTLOOP 1
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorPreInclude' */
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_TEXCOORD1
            #define ATTRIBUTES_NEED_TEXCOORD2
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
            #define VARYINGS_NEED_TEXCOORD1
            #define VARYINGS_NEED_TEXCOORD2
        
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
            #define FRAG_INPUTS_USE_TEXCOORD1
            #define FRAG_INPUTS_USE_TEXCOORD2
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracingLightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/HairRayTracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingLightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        
            //Interpolator Packs: <None>
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            // GraphVertex: <None>
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorCopyToSDI' */
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassRaytracingForward.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "GBufferDXR"
            Tags
            {
                "LightMode" = "GBufferDXR"
            }
        
            // Render State
            // RenderState: <None>
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma target 5.0
        #pragma raytracing surface_shader
        #pragma only_renderers d3d11 xboxseries ps5
        
            // Keywords
            #pragma multi_compile _ MINIMAL_GBUFFER
        #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma multi_compile _ DEBUG_DISPLAY
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
        #pragma shader_feature_local_fragment _ _DISABLE_SSR
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR
        #pragma shader_feature_local_fragment _ _DISABLE_SSR_TRANSPARENT
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR_TRANSPARENT
        #pragma multi_compile _ LIGHTMAP_ON
        #pragma multi_compile _ DIRLIGHTMAP_COMBINED
        #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile_raytracing _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile _ DYNAMICLIGHTMAP_ON
        #pragma multi_compile_raytracing DECALS_OFF DECALS_3RT DECALS_4RT
        #pragma multi_compile_raytracing _ DECAL_SURFACE_GRADIENT
            // GraphKeywords: <None>
        
            // Defines
            #define SHADERPASS SHADERPASS_RAYTRACING_GBUFFER
        #define PUNCTUAL_SHADOW_LOW
        #define DIRECTIONAL_SHADOW_LOW
        #define RAYTRACING_SHADER_GRAPH_RAYTRACED
        #define LIGHTLOOP_DISABLE_TILE_AND_CLUSTER 1
        #define PATH_TRACING_CLUSTERED_DECALS 1
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorPreInclude' */
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_TEXCOORD1
            #define ATTRIBUTES_NEED_TEXCOORD2
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
            #define VARYINGS_NEED_TEXCOORD1
            #define VARYINGS_NEED_TEXCOORD2
        
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
            #define FRAG_INPUTS_USE_TEXCOORD1
            #define FRAG_INPUTS_USE_TEXCOORD2
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracingLightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/Deferred/RaytracingIntersectonGBuffer.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/StandardLit/StandardLit.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/HairRayTracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        
            //Interpolator Packs: <None>
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            // GraphVertex: <None>
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorCopyToSDI' */
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassRaytracingGBuffer.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
        Pass
        {
            Name "DebugDXR"
            Tags
            {
                "LightMode" = "DebugDXR"
            }
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma target 5.0
        #pragma raytracing surface_shader
        #pragma only_renderers d3d11 xboxseries ps5
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
        	// GraphIncludes: <None>
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassRayTracingDebug.hlsl"
        
            ENDHLSL
        }
        Pass
        {
            Name "PathTracingDXR"
            Tags
            {
                "LightMode" = "PathTracingDXR"
            }
        
            // Render State
            // RenderState: <None>
        
            // Debug
            // <None>
        
            // --------------------------------------------------
            // Pass
        
            HLSLPROGRAM
        
            // Pragmas
            #pragma target 5.0
        #pragma raytracing surface_shader
        #pragma only_renderers d3d11 xboxseries ps5
        
            // Keywords
            #pragma shader_feature_local _ _ALPHATEST_ON
        #pragma shader_feature _ _SURFACE_TYPE_TRANSPARENT
        #pragma shader_feature_local _ _DOUBLESIDED_ON
        #pragma multi_compile _ DEBUG_DISPLAY
        #pragma shader_feature_local_fragment _ _DISABLE_DECALS
        #pragma shader_feature_local_raytracing _ _DISABLE_DECALS
        #pragma shader_feature_local_fragment _ _DISABLE_SSR
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR
        #pragma shader_feature_local_fragment _ _DISABLE_SSR_TRANSPARENT
        #pragma shader_feature_local_raytracing _ _DISABLE_SSR_TRANSPARENT
        #pragma multi_compile _ LIGHTMAP_ON
        #pragma multi_compile _ DIRLIGHTMAP_COMBINED
        #pragma multi_compile_fragment _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile_raytracing _ PROBE_VOLUMES_L1 PROBE_VOLUMES_L2
        #pragma multi_compile _ DYNAMICLIGHTMAP_ON
        #pragma multi_compile_raytracing DECALS_OFF DECALS_3RT DECALS_4RT
        #pragma multi_compile_raytracing _ DECAL_SURFACE_GRADIENT
            // GraphKeywords: <None>
        
            // Defines
            #define SHADERPASS SHADERPASS_PATH_TRACING
        #define PUNCTUAL_SHADOW_LOW
        #define DIRECTIONAL_SHADOW_LOW
        #define RAYTRACING_SHADER_GRAPH_PATHTRACED
        #define LIGHTLOOP_DISABLE_TILE_AND_CLUSTER 1
        #define PATH_TRACING_CLUSTERED_DECALS 1
        #define HAS_LIGHTLOOP 1
        #define SUPPORT_GLOBAL_MIP_BIAS 1
        
            // For custom interpolators to inject a substruct definition before FragInputs definition,
            // allowing for FragInputs to capture CI's intended for ShaderGraph's SDI.
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorPreInclude' */
        
        
            // TODO: Merge FragInputsVFX substruct with CustomInterpolators.
        	#ifdef HAVE_VFX_MODIFICATION
        	struct FragInputsVFX
            {
                /* WARNING: $splice Could not find named fragment 'FragInputsVFX' */
            };
            #endif
        
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/GeometricTools.hlsl" // Required by Tessellation.hlsl
        	#include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Tessellation.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Texture.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderVariables.hlsl"
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPass.cs.hlsl"
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/TextureStack.hlsl" // Required to be include before we include properties as it define DECLARE_STACK_CB
            #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/DebugMipmapStreamingMacros.hlsl" // Required before including properties as it defines UNITY_TEXTURE_STREAMING_DEBUG_VARS
            // Always include Shader Graph version
            // Always include last to avoid double macros
            #include "Packages/com.unity.shadergraph/ShaderGraphLibrary/Functions.hlsl" // Need to be here for Gradient struct definition
        
            // --------------------------------------------------
            // Defines
        
            // Attribute
            #define ATTRIBUTES_NEED_NORMAL
            #define ATTRIBUTES_NEED_TANGENT
            #define ATTRIBUTES_NEED_TEXCOORD0
            #define ATTRIBUTES_NEED_TEXCOORD1
            #define ATTRIBUTES_NEED_TEXCOORD2
            #define VARYINGS_NEED_POSITION_WS
            #define VARYINGS_NEED_TANGENT_TO_WORLD
            #define VARYINGS_NEED_TEXCOORD0
            #define VARYINGS_NEED_TEXCOORD1
            #define VARYINGS_NEED_TEXCOORD2
        
        
            //Strip down the FragInputs.hlsl (on graphics), so we can only optimize the interpolators we use.
            //if by accident something requests contents of FragInputs.hlsl, it will be caught as a compiler error
            //Frag inputs stripping is only enabled when FRAG_INPUTS_ENABLE_STRIPPING is set
            #if !defined(SHADER_STAGE_RAY_TRACING) && SHADERPASS != SHADERPASS_RAYTRACING_GBUFFER && SHADERPASS != SHADERPASS_FULL_SCREEN_DEBUG
            #define FRAG_INPUTS_ENABLE_STRIPPING
            #endif
            #define FRAG_INPUTS_USE_TEXCOORD0
            #define FRAG_INPUTS_USE_TEXCOORD1
            #define FRAG_INPUTS_USE_TEXCOORD2
        
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/FragInputs.hlsl"
        
        
            #define _ADD_CUSTOM_VELOCITY
        
        
            // Following two define are a workaround introduce in 10.1.x for RaytracingQualityNode
            // The ShaderGraph don't support correctly migration of this node as it serialize all the node data
            // in the json file making it impossible to uprgrade. Until we get a fix, we do a workaround here
            // to still allow us to rename the field and keyword of this node without breaking existing code.
            #ifdef RAYTRACING_SHADER_GRAPH_DEFAULT
            #define RAYTRACING_SHADER_GRAPH_HIGH
            #endif
        
            #ifdef RAYTRACING_SHADER_GRAPH_RAYTRACED
            #define RAYTRACING_SHADER_GRAPH_LOW
            #endif
            // end
        
            #ifndef SHADER_UNLIT
            // We need isFrontFace when using double sided - it is not required for unlit as in case of unlit double sided only drive the cullmode
            // VARYINGS_NEED_CULLFACE can be define by VaryingsMeshToPS.FaceSign input if a IsFrontFace Node is included in the shader graph.
            #if defined(_DOUBLESIDED_ON) && !defined(VARYINGS_NEED_CULLFACE)
                #define VARYINGS_NEED_CULLFACE
            #endif
            #endif
        
            // Specific Material Define
        #define _MATERIAL_FEATURE_HAIR_KAJIYA_KAY 1
        #define _AMBIENT_OCCLUSION 1
        #define _SPECULAR_OCCLUSION_FROM_AO 1
        #define _ABSORPTION_FROM_COLOR 1
        #define _ENVIRONMENT_LIGHT_SAMPLE_COUNT 8
        #define _AREA_LIGHT_SAMPLE_COUNT 8
            // Caution: we can use the define SHADER_UNLIT onlit after the above Material include as it is the Unlit template who define it
        
            // To handle SSR on transparent correctly with a possibility to enable/disable it per framesettings
            // we should have a code like this:
            // if !defined(_DISABLE_SSR_TRANSPARENT)
            // pragma multi_compile _ WRITE_NORMAL_BUFFER
            // endif
            // i.e we enable the multicompile only if we can receive SSR or not, and then C# code drive
            // it based on if SSR transparent in frame settings and not (and stripper can strip it).
            // this is currently not possible with our current preprocessor as _DISABLE_SSR_TRANSPARENT is a keyword not a define
            // so instead we used this and chose to pay the extra cost of normal write even if SSR transaprent is disabled.
            // Ideally the shader graph generator should handle it but condition below can't be handle correctly for now.
            #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
            #if !defined(_DISABLE_SSR_TRANSPARENT) && !defined(SHADER_UNLIT)
                #define WRITE_NORMAL_BUFFER
            #endif
            #endif
        
            // See Lit.shader
            #if SHADERPASS == SHADERPASS_MOTION_VECTORS && defined(WRITE_DECAL_BUFFER_AND_RENDERING_LAYER)
                #define WRITE_DECAL_BUFFER
            #endif
        
            #ifndef DEBUG_DISPLAY
                // In case of opaque we don't want to perform the alpha test, it is done in depth prepass and we use depth equal for ztest (setup from UI)
                // Don't do it with debug display mode as it is possible there is no depth prepass in this case
                #if !defined(_SURFACE_TYPE_TRANSPARENT)
                    #if SHADERPASS == SHADERPASS_FORWARD
                    #define SHADERPASS_FORWARD_BYPASS_ALPHA_TEST
                    #elif SHADERPASS == SHADERPASS_GBUFFER
                    #define SHADERPASS_GBUFFER_BYPASS_ALPHA_TEST
                    #endif
                #endif
            #endif
        
            // Define _DEFERRED_CAPABLE_MATERIAL for shader capable to run in deferred pass
            #if defined(SHADER_LIT) && !defined(_SURFACE_TYPE_TRANSPARENT)
                #define _DEFERRED_CAPABLE_MATERIAL
            #endif
        
            // Translate transparent motion vector define
            #if (defined(_TRANSPARENT_WRITES_MOTION_VEC) || defined(_TRANSPARENT_REFRACTIVE_SORT)) && defined(_SURFACE_TYPE_TRANSPARENT)
                #define _WRITE_TRANSPARENT_MOTION_VECTOR
            #endif
        
            // -- Graph Properties
            CBUFFER_START(UnityPerMaterial)
        float2 _InstanceData;
        float4 _DiffuseMap_TexelSize;
        float2 _Diffuse_Offset;
        float2 _Diffuse_Tiling;
        float4 _DiffuseColor;
        float _DiffuseStrength;
        float _AlphaPower;
        float _AlphaRemap;
        float _AlphaClip;
        float _ShadowClip;
        float _DepthPrepass;
        float _DepthPostpass;
        float4 _MaskMap_TexelSize;
        float _AOStrength;
        float _AOOccludeAll;
        float _SmoothnessPower;
        float _SmoothnessMin;
        float _SmoothnessMax;
        float _SecondarySmoothness;
        float4 _NormalMap_TexelSize;
        float _NormalStrength;
        float4 _BlendMap_TexelSize;
        float _BlendStrength;
        float4 _FlowMap_TexelSize;
        float _FlowMapFlipGreen;
        float4 _SpecularMap_TexelSize;
        float4 _SpecularTint;
        float _SpecularMultiplier;
        float _SpecularShiftMin;
        float _SpecularShiftMax;
        float _SecondarySpecularMultiplier;
        float _SecondarySpecularShift;
        float _RimTransmissionIntensity;
        float4 _EmissionMap_TexelSize;
        float4 _EmissiveColor;
        float4 _RootMap_TexelSize;
        float _BaseColorStrength;
        float _GlobalStrength;
        float _RootColorStrength;
        float _EndColorStrength;
        float _InvertRootMap;
        float4 _RootColor;
        float4 _EndColor;
        float4 _IDMap_TexelSize;
        float _HighlightBlend;
        float _HighlightAStrength;
        float4 _HighlightAColor;
        float3 _HighlightADistribution;
        float _HighlightAOverlapEnd;
        float _HighlightAOverlapInvert;
        float _HighlightBStrength;
        float4 _HighlightBColor;
        float3 _HighlightBDistribution;
        float _HighlightBOverlapEnd;
        float _HighlightBOverlapInvert;
        float _TransmittanceMultiplier;
        float4 _EmissionColor;
        float _UseShadowThreshold;
        float4 _DoubleSidedConstants;
        UNITY_TEXTURE_STREAMING_DEBUG_VARS;
        float _BlendMode;
        float _EnableBlendModePreserveSpecularLighting;
        CBUFFER_END
        
        #if defined(DOTS_INSTANCING_ON)
        // DOTS instancing definitions
        UNITY_DOTS_INSTANCING_START(MaterialPropertyMetadata)
            UNITY_DOTS_INSTANCED_PROP_OVERRIDE_SUPPORTED(float2, _InstanceData)
        UNITY_DOTS_INSTANCING_END(MaterialPropertyMetadata)
        // DOTS instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_DOTS_INSTANCED_PROP_WITH_DEFAULT(type, var)
        #elif defined(UNITY_INSTANCING_ENABLED)
        // Unity instancing definitions
        UNITY_INSTANCING_BUFFER_START(SGPerInstanceData)
            UNITY_DEFINE_INSTANCED_PROP(float2, _InstanceData)
        UNITY_INSTANCING_BUFFER_END(SGPerInstanceData)
        // Unity instancing usage macros
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) UNITY_ACCESS_INSTANCED_PROP(SGPerInstanceData, var)
        #else
        #define UNITY_ACCESS_HYBRID_INSTANCED_PROP(var, type) var
        #endif
        
        // Object and Global properties
        SAMPLER(SamplerState_Linear_Clamp);
        SAMPLER(SamplerState_Linear_Repeat);
        TEXTURE2D(_DiffuseMap);
        SAMPLER(sampler_DiffuseMap);
        TEXTURE2D(_MaskMap);
        SAMPLER(sampler_MaskMap);
        TEXTURE2D(_NormalMap);
        SAMPLER(sampler_NormalMap);
        TEXTURE2D(_BlendMap);
        SAMPLER(sampler_BlendMap);
        TEXTURE2D(_FlowMap);
        SAMPLER(sampler_FlowMap);
        TEXTURE2D(_SpecularMap);
        SAMPLER(sampler_SpecularMap);
        TEXTURE2D(_EmissionMap);
        SAMPLER(sampler_EmissionMap);
        TEXTURE2D(_RootMap);
        SAMPLER(sampler_RootMap);
        TEXTURE2D(_IDMap);
        SAMPLER(sampler_IDMap);
        
            // -- Property used by ScenePickingPass
            #ifdef SCENEPICKINGPASS
            float4 _SelectionID;
            #endif
        
            // -- Properties used by SceneSelectionPass
            #ifdef SCENESELECTIONPASS
            int _ObjectId;
            int _PassValue;
            #endif
        
            // Includes
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingMacros.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Material.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/ShaderVariablesRaytracingLightLoop.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RaytracingIntersection.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/Lighting.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Lighting/LightLoop/LightLoopDef.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingLightCluster.hlsl"
        #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/NormalSurfaceGradient.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/Hair.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Hair/HairPathTracing.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/BuiltinUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/MaterialUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/Raytracing/Shaders/RayTracingCommon.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/Material/Decal/DecalUtilities.hlsl"
        #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/ShaderGraphFunctions.hlsl"
            // GraphIncludes: <None>
        
            // --------------------------------------------------
            // Structs and Packing
        
            struct SurfaceDescriptionInputs
        {
             float3 TangentSpaceNormal;
             float4 uv0;
        };
        
            //Interpolator Packs: <None>
        
            // --------------------------------------------------
            // Graph
        
        
            // Graph Functions
            
        void Unity_TilingAndOffset_float(float2 UV, float2 Tiling, float2 Offset, out float2 Out)
        {
            Out = UV * Tiling + Offset;
        }
        
        void Unity_Lerp_float4(float4 A, float4 B, float4 T, out float4 Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_OneMinus_float(float In, out float Out)
        {
            Out = 1 - In;
        }
        
        void Unity_Lerp_float(float A, float B, float T, out float Out)
        {
            Out = lerp(A, B, T);
        }
        
        void Unity_Multiply_float_float(float A, float B, out float Out)
        {
        Out = A * B;
        }
        
        struct Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float
        {
        };
        
        void SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(float Vector1_0a6faa92a7154e1ea2c79930adc12567, float Vector1_279ecd9896744ec093d2d54dbc96c800, float Vector1_61eaedfb17b64a7387f691c8c7e9e081, float4 Color_861ac28fe6eb445d80ad76e07e3141e7, float4 Color_8e26babb1fd14dcabe8f71fff80509b2, float Vector1_457b04a00dee47d1b8fa85ec713abc5c, float Vector1_7354e715df774b759c8448aa2dbd2281, float Vector1_76266c9cfce9426c95d75f44262fe910, float4 Color_6b72dfab887a48738da543f1dd2fb798, Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float IN, out float4 Color_1, out float RootMap_3, out float InvertedRootMap_2)
        {
        float4 _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4 = Color_6b72dfab887a48738da543f1dd2fb798;
        float _Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float = Vector1_61eaedfb17b64a7387f691c8c7e9e081;
        float4 _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4;
        Unity_Lerp_float4(float4(1, 1, 1, 1), _Property_fe71902352f04011b6a752e7663af954_Out_0_Vector4, (_Property_3815e01725ff4a44bfae96c1035a12d0_Out_0_Float.xxxx), _Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4);
        float4 _Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4 = Color_861ac28fe6eb445d80ad76e07e3141e7;
        float4 _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4 = Color_8e26babb1fd14dcabe8f71fff80509b2;
        float _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float = Vector1_0a6faa92a7154e1ea2c79930adc12567;
        float _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        Unity_OneMinus_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float);
        float _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float = Vector1_279ecd9896744ec093d2d54dbc96c800;
        float _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float;
        Unity_Lerp_float(_Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float, _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float, _Property_4e65d095b82a4e69967218b3cd1a1fc9_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float);
        float4 _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4;
        Unity_Lerp_float4(_Property_fb76293df6a140088bebea750f43eeff_Out_0_Vector4, _Property_ecd5ecf95d834553973f09dd2153302c_Out_0_Vector4, (_Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float.xxxx), _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4);
        float _Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float = Vector1_457b04a00dee47d1b8fa85ec713abc5c;
        float _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float = Vector1_7354e715df774b759c8448aa2dbd2281;
        float _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float;
        Unity_Lerp_float(_Property_1cc9801b92af40ae816aa11a091652ba_Out_0_Float, _Property_094e5e0289c54e8baacf9a2da3a01c42_Out_0_Float, _Lerp_0e6e2ab3b4414eaa8ece20e5f6cf78f7_Out_3_Float, _Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float);
        float _Property_71505450457d45c48f42786aca84e865_Out_0_Float = Vector1_76266c9cfce9426c95d75f44262fe910;
        float _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float;
        Unity_Multiply_float_float(_Lerp_5e651467593d4094bdd56ac842b30c3b_Out_3_Float, _Property_71505450457d45c48f42786aca84e865_Out_0_Float, _Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float);
        float4 _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        Unity_Lerp_float4(_Lerp_b3624d78c8bb4444b43cf220f7e2de82_Out_3_Vector4, _Lerp_55f47a851d104506a8dcd1fa633b1478_Out_3_Vector4, (_Multiply_5937ae30e26340c0aaed1b25aace6d9a_Out_2_Float.xxxx), _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4);
        Color_1 = _Lerp_a8b6405a4b37464bb78f10ee836d4025_Out_3_Vector4;
        RootMap_3 = _Property_7343d60dfe944be49479f67294b98cd6_Out_0_Float;
        InvertedRootMap_2 = _OneMinus_5b54997f669942da987e7c6543d93092_Out_1_Float;
        }
        
        // unity-custom-func-begin
        void _3PointDist_float(float In, float3 From, float Fac, out float Out){
        float lower = smoothstep(From.x, From.y, In);
        float upper = 1.0 - smoothstep(From.y, From.z, In);
        Out = Fac * lerp(lower, upper, step(From.y, In));
        }
        // unity-custom-func-end
        
        void Unity_Saturate_float(float In, out float Out)
        {
            Out = saturate(In);
        }
        
        struct Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float
        {
        };
        
        void SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(float4 Color_6c9ad01bba954b8da6d8dd0457f1d21e, float Vector1_31cfc28f88b24953b57b639f41e5ddac, float Vector1_d49097a42b81462aa5c07ca46b98a1c6, float Vector1_b8b5d184da264abf95d567226a7f40e5, float3 Vector3_8bc6eceefbd44bd6b314a6c4fece8a78, float Vector1_1c86bb3577cb401ab58253bc844f14b3, float4 Color_c1185163b18e49c1afd6ece47dd69537, float Vector1_635b5ea0f7da485f879e85c20c3a0273, float Vector1_1eca0e3642514c9aad30757fb0a5aa58, float Vector1_a97a069f296645dc9aba61dbc2f0ae27, Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float IN, out float4 Color_1)
        {
        float4 _Property_487873356a46427583b829f840dab363_Out_0_Vector4 = Color_6c9ad01bba954b8da6d8dd0457f1d21e;
        float4 _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4 = Color_c1185163b18e49c1afd6ece47dd69537;
        float _Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float = Vector1_b8b5d184da264abf95d567226a7f40e5;
        float3 _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3 = Vector3_8bc6eceefbd44bd6b314a6c4fece8a78;
        float _Property_a07b88b79109436db8784f679d586777_Out_0_Float = Vector1_1c86bb3577cb401ab58253bc844f14b3;
        float _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float;
        _3PointDist_float(_Property_3298d24ba5794980a54b5078bd722a1d_Out_0_Float, _Property_7096956270a14f729a923a06f6d97015_Out_0_Vector3, _Property_a07b88b79109436db8784f679d586777_Out_0_Float, _var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float);
        float _Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float = Vector1_635b5ea0f7da485f879e85c20c3a0273;
        float _Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float = Vector1_31cfc28f88b24953b57b639f41e5ddac;
        float _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float = Vector1_d49097a42b81462aa5c07ca46b98a1c6;
        float _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float = Vector1_1eca0e3642514c9aad30757fb0a5aa58;
        float _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float;
        Unity_Lerp_float(_Property_eddba7ec49504a62bc3e4f2b10f5547c_Out_0_Float, _Property_f5e48639aed84a2896bda024a6c15dcc_Out_0_Float, _Property_2efeba2768ae47eb975e6a84aa982103_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float);
        float _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float;
        Unity_Multiply_float_float(_Property_f35cb1254f5048d5a1aa23c03e0aa175_Out_0_Float, _Lerp_7652aef9e81e4dce9cc5a22266f735af_Out_3_Float, _Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float);
        float _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float;
        Unity_OneMinus_float(_Multiply_8e787b1417e346ec9d057dab97fdc03b_Out_2_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float);
        float _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float;
        Unity_Multiply_float_float(_var3PointDistCustomFunction_456ccaae9d3e461c83b9dad5c10aa54a_Out_3_Float, _OneMinus_b7cd3543abc249b0b822f116e9dd6743_Out_1_Float, _Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float);
        float _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float = Vector1_a97a069f296645dc9aba61dbc2f0ae27;
        float _Multiply_188b868d21074361a47903f038987130_Out_2_Float;
        Unity_Multiply_float_float(_Multiply_e49f8b899e9c4d14bbe6df60ad1d2fd4_Out_2_Float, _Property_d2a34e252894400aa002e54c2a4b62f2_Out_0_Float, _Multiply_188b868d21074361a47903f038987130_Out_2_Float);
        float _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float;
        Unity_Saturate_float(_Multiply_188b868d21074361a47903f038987130_Out_2_Float, _Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float);
        float4 _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        Unity_Lerp_float4(_Property_487873356a46427583b829f840dab363_Out_0_Vector4, _Property_5fb7795d95c44f328cefe8da273297dc_Out_0_Vector4, (_Saturate_3a016bc2a6764f93ab05dae148ff6fe7_Out_1_Float.xxxx), _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4);
        Color_1 = _Lerp_0ea9f0c8cd2c4ac69f1a8cf91bb37a85_Out_3_Vector4;
        }
        
        void Unity_Multiply_float4_float4(float4 A, float4 B, out float4 Out)
        {
        Out = A * B;
        }
        
        void Unity_Blend_Multiply_float4(float4 Base, float4 Blend, out float4 Out, float Opacity)
        {
            Out = Base * Blend;
            Out = lerp(Base, Out, Opacity);
        }
        
        struct Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float
        {
        };
        
        void SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(float4 Color_b92efa18ca1c4ade9cca3ccc104af1a1, float Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0, float Vector1_0f238e71cd7b40a09c04b8f2635cd899, float Vector1_a3f517b2d71f4fd4a918bcec3474a52a, float4 Color_2aaca955161c4922a5504ae6032e34a7, float Vector1_a4b9c8b6879a413ab32d2cdf9c765211, float Vector1_7203013050f2495891b7f260963be1ef, Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float IN, out float4 Color_1)
        {
        float4 _Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4 = Color_2aaca955161c4922a5504ae6032e34a7;
        float _Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float = Vector1_0f238e71cd7b40a09c04b8f2635cd899;
        float4 _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4 = Color_b92efa18ca1c4ade9cca3ccc104af1a1;
        float4 _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4;
        Unity_Multiply_float4_float4((_Property_f831479b6d4f4715aa0251d75db5b358_Out_0_Float.xxxx), _Property_f50c2c05ced54c609e22d8fe75240d1d_Out_0_Vector4, _Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4);
        float _Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float = Vector1_88a8d7bbbeb148d69fcd7219cfaa64e0;
        float _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float = Vector1_a3f517b2d71f4fd4a918bcec3474a52a;
        float4 _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Multiply_d22d7aeb7f9549faa7a31c0a83b18987_Out_2_Vector4, (_Property_836ad50b83fb40348bcb4b643436de05_Out_0_Float.xxxx), _Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, _Property_7e7a19a11ef14087b2fae8332caa3b50_Out_0_Float);
        float _Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float = Vector1_7203013050f2495891b7f260963be1ef;
        float _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float = Vector1_a4b9c8b6879a413ab32d2cdf9c765211;
        float4 _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4;
        Unity_Blend_Multiply_float4(_Blend_294f02fe556d4299a56b486b48c8a623_Out_2_Vector4, (_Property_5acee3642f2a4d979277ea018eda6b7c_Out_0_Float.xxxx), _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Property_4e72bb784de6446d9dff2f8a4235ed83_Out_0_Float);
        float4 _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        Unity_Multiply_float4_float4(_Property_52c2bc19d1574d7886152369b846c57d_Out_0_Vector4, _Blend_131f44ae42a54328b9f08da998818163_Out_2_Vector4, _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4);
        Color_1 = _Multiply_fc5b1a50834b4d4d8a635f1ab5506263_Out_2_Vector4;
        }
        
        void Unity_Divide_float(float A, float B, out float Out)
        {
            Out = A / B;
        }
        
        void Unity_Power_float(float A, float B, out float Out)
        {
            Out = pow(A, B);
        }
        
        void Unity_Step_float(float Edge, float In, out float Out)
        {
            Out = step(Edge, In);
        }
        
        void Unity_Maximum_float(float A, float B, out float Out)
        {
            Out = max(A, B);
        }
        
        void Unity_NormalStrength_float(float3 In, float Strength, out float3 Out)
        {
            Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
        }
        
        void Unity_Combine_float(float R, float G, float B, float A, out float4 RGBA, out float3 RGB, out float2 RG)
        {
            RGBA = float4(R, G, B, A);
            RGB = float3(R, G, B);
            RG = float2(R, G);
        }
        
        void Unity_Add_float(float A, float B, out float Out)
        {
            Out = A + B;
        }
        
            // Graph Vertex
            // GraphVertex: <None>
        
            // Graph Pixel
            struct SurfaceDescription
        {
            float3 BaseColor;
            float3 Emission;
            float Alpha;
            float AlphaClipThreshold;
            float AlphaClipThresholdDepthPrepass;
            float AlphaClipThresholdDepthPostpass;
            float AlphaClipThresholdShadow;
            float3 BentNormal;
            float Smoothness;
            float Occlusion;
            float3 NormalTS;
            float3 HairStrandDirection;
            float3 Transmittance;
            float RimTransmissionIntensity;
            float3 SpecularTint;
            float SpecularShift;
            float3 SecondarySpecularTint;
            float SecondarySmoothness;
            float SecondarySpecularShift;
        };
        
        SurfaceDescription SurfaceDescriptionFunction(SurfaceDescriptionInputs IN)
        {
            SurfaceDescription surface = (SurfaceDescription)0;
            UnityTexture2D _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_RootMap);
            float4 _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_6ecff3af82ac40418c956f8a38fda7d3_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_R_4_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.r;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.g;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_B_6_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.b;
            float _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_A_7_Float = _SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_RGBA_0_Vector4.a;
            float _Property_2f84847c491547739e60664b75884634_Out_0_Float = _InvertRootMap;
            float _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float = _BaseColorStrength;
            float4 _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4 = _RootColor;
            float4 _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4 = _EndColor;
            float _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float = _RootColorStrength;
            float _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float = _EndColorStrength;
            float _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float = _GlobalStrength;
            UnityTexture2D _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_DiffuseMap);
            float2 _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2 = _Diffuse_Tiling;
            float2 _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2 = _Diffuse_Offset;
            float2 _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2;
            Unity_TilingAndOffset_float(IN.uv0.xy, _Property_2e2f3b43ca1f4087aae5180f780e63ad_Out_0_Vector2, _Property_9f1a1192ba1445659300de459744960e_Out_0_Vector2, _TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2);
            float4 _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Clamp).samplerstate, _Property_5f984a05a60b4f76afa0ec01041e1d96_Out_0_Texture2D.GetTransformedUV(_TilingAndOffset_3dc9a9585dc144b69b069da48b2188cd_Out_3_Vector2) );
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_R_4_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.r;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_G_5_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.g;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_B_6_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.b;
            float _SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float = _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4.a;
            Bindings_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780;
            float4 _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float;
            float _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float;
            SG_RLFunctionHairRootBlend_7e332a8c36226cd43a71eddf58c5dbb2_float(_SampleTexture2D_bfcbbb8f16894a09b2943bd4af0e7e17_G_5_Float, _Property_2f84847c491547739e60664b75884634_Out_0_Float, _Property_cd5616f7b08c4b37bb7a7b56afc8ca2b_Out_0_Float, _Property_1e6a1a093dfc4253ab60cb89cdbd500a_Out_0_Vector4, _Property_c2f112e363d049f68f0c3b3031c18f06_Out_0_Vector4, _Property_04af8ce2ede54180b9c27045bc9d754e_Out_0_Float, _Property_b86246fa0fff40a284f03275fff93bcf_Out_0_Float, _Property_f2b7d300cc4c41a09579db62531aa14a_Out_0_Float, _SampleTexture2D_fe251668acaf4cc1a186f88895925031_RGBA_0_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float);
            UnityTexture2D _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_IDMap);
            float4 _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_86455e4666b643bf91cfbaf131d45eb1_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_R_4_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.r;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.g;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_B_6_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.b;
            float _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_A_7_Float = _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_RGBA_0_Vector4.a;
            float3 _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3 = _HighlightADistribution;
            float _Property_37d47e939df243e19df140caeabc6088_Out_0_Float = _HighlightAStrength;
            float4 _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4 = _HighlightAColor;
            float _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float = _HighlightAOverlapEnd;
            float _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float = _HighlightAOverlapInvert;
            float _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e;
            float4 _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_6d00c754a1b5489990a6a6f802a8492c_Out_0_Vector3, _Property_37d47e939df243e19df140caeabc6088_Out_0_Float, _Property_89491350ac6841c3a2b4c3034afd4d94_Out_0_Vector4, _Property_5b2deb6b50d54492944439b12c257cfa_Out_0_Float, _Property_d875584c381349c8be1fd7ec51b347ee_Out_0_Float, _Property_5bc635bdec7b4b6fa6ad02c7da15483e_Out_0_Float, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e, _RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4);
            float3 _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3 = _HighlightBDistribution;
            float _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float = _HighlightBStrength;
            float4 _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4 = _HighlightBColor;
            float _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float = _HighlightBOverlapEnd;
            float _Property_e914554d54e64faf9720389438495a70_Out_0_Float = _HighlightBOverlapInvert;
            float _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float = _HighlightBlend;
            Bindings_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6;
            float4 _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4;
            SG_RLFunctionHairIDBlend_bde8ceb926def2e4eb1b7c8cc5ca837a_float(_RLFunctionHairIDBlend_4587cd70f08d4219aec085cbfacc455e_Color_1_Vector4, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_RootMap_3_Float, _RLFunctionHairRootBlend_30d7b7c88b1e4ca7ab29f0f64e00e780_InvertedRootMap_2_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Property_d39a9113840a4a86b90ff79526878a19_Out_0_Vector3, _Property_7885d7a85a524469bed829c26fcc314a_Out_0_Float, _Property_9f8c21dd3c144973a99de8440ff1910d_Out_0_Vector4, _Property_fa23d0762b1842e38b1ce87344837242_Out_0_Float, _Property_e914554d54e64faf9720389438495a70_Out_0_Float, _Property_0c37745b9db347df895bdf6959d8b54a_Out_0_Float, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6, _RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4);
            UnityTexture2D _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_BlendMap);
            float4 _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_fdc1fb91fa83476caa363209cb103fd5_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_R_4_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.r;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.g;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_B_6_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.b;
            float _SampleTexture2D_a9b949905222445081591fa1fd11be88_A_7_Float = _SampleTexture2D_a9b949905222445081591fa1fd11be88_RGBA_0_Vector4.a;
            float _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float = _DiffuseStrength;
            float _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float = _BlendStrength;
            float4 _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4 = _DiffuseColor;
            float _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float = _AOOccludeAll;
            UnityTexture2D _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_MaskMap);
            float4 _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_5bc2e2ebb6e84033be0c02d88425a9d9_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_R_4_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.r;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.g;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_B_6_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.b;
            float _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float = _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_RGBA_0_Vector4.a;
            float _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float = _AOStrength;
            float _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            Unity_Lerp_float(float(1), _SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_G_5_Float, _Property_d0cc3b3b53f440678f753c7d24288c01_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float);
            Bindings_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff;
            float4 _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4;
            SG_RLFunctionHairVertexColorBlend_deb5adbd3a758b848aeaafef037de569_float(_RLFunctionHairIDBlend_bbe04f86f125496799c490907438d1f6_Color_1_Vector4, _SampleTexture2D_a9b949905222445081591fa1fd11be88_G_5_Float, _Property_c82337ad5b6a41fba467321b6a383a9f_Out_0_Float, _Property_f4274b5ff3ad4120a550c1bfb31fe327_Out_0_Float, _Property_ee460cabf5104a9d845b08a5c98529c2_Out_0_Vector4, _Property_0917d75185d9443586c46f1f88fff814_Out_0_Float, _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff, _RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4);
            float4 _Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4 = IsGammaSpace() ? LinearToSRGB(_EmissiveColor) : _EmissiveColor;
            UnityTexture2D _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_EmissionMap);
            float4 _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_4e86ff273f104b47a35a04b03339a9d7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_R_4_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.r;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_G_5_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.g;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_B_6_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.b;
            float _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_A_7_Float = _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4.a;
            float4 _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Property_6751a374553d44a6894f2606ce3151ca_Out_0_Vector4, _SampleTexture2D_6cf2216245ca4c94a226d2a52deb5633_RGBA_0_Vector4, _Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4);
            float _Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float = _DepthPrepass;
            float _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float = _AlphaRemap;
            float _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float;
            Unity_Divide_float(_SampleTexture2D_fe251668acaf4cc1a186f88895925031_A_7_Float, _Property_dd6f6572051e4d659f72bb5b91baefdc_Out_0_Float, _Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float);
            float _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float;
            Unity_Saturate_float(_Divide_ac70eb9a271a4e2eb7c2e15fb1d4c989_Out_2_Float, _Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float);
            float _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float = _AlphaPower;
            float _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float;
            Unity_Power_float(_Saturate_b8e284dd58dd45a6b6c14058a8baffad_Out_1_Float, _Property_6f6152d8538648468b848cd049b3d36d_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float);
            float _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float;
            Unity_Step_float(_Property_84d2793a294b47a5a14c5b627a6f56b5_Out_0_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float);
            float _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            Unity_Maximum_float(_Step_5597458525674bf7a3182baa7b9ac3f0_Out_2_Float, _Power_f82f65e9659e476a81e3fd01ec59c77d_Out_2_Float, _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float);
            float _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float = _AlphaClip;
            float _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float = _DepthPrepass;
            float _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float = _DepthPostpass;
            float _Property_eba48f1e544d455986b250277b538909_Out_0_Float = _ShadowClip;
            float _Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float = _SmoothnessMin;
            float _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float = _SmoothnessMax;
            float _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float;
            Unity_Saturate_float(_SampleTexture2D_454e8678d7fa4d8583459d67c01c0d1d_A_7_Float, _Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float);
            float _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float = _SmoothnessPower;
            float _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float;
            Unity_Power_float(_Saturate_ed8723b9b07a4e8bbf6b6a7e73ceff66_Out_1_Float, _Property_0569c2035ccd497a872ea10ea40d4e43_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float);
            float _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            Unity_Lerp_float(_Property_51595b2e0ca547c0a312a7b88240ed30_Out_0_Float, _Property_114b289fef094d4fb9b6da23caaeb079_Out_0_Float, _Power_3b743ddc9ad64097a3679e91b83ab546_Out_2_Float, _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float);
            UnityTexture2D _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_NormalMap);
            float4 _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_f15873d7cae54a328809df9a8d76bbf7_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4);
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_R_4_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.r;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_G_5_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.g;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_B_6_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.b;
            float _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_A_7_Float = _SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.a;
            float _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float = _NormalStrength;
            float3 _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            Unity_NormalStrength_float((_SampleTexture2D_af7e3800e2f34908a3a77b8948d2fd32_RGBA_0_Vector4.xyz), _Property_45445a2f270b47348746e62d75ebd6c7_Out_0_Float, _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3);
            UnityTexture2D _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_FlowMap);
            float4 _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_204a9b15f9994d9e87d7f8dcda2b5087_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.rgb = UnpackNormal(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4);
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.r;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.g;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.b;
            float _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float = _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_RGBA_0_Vector4.a;
            float _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float;
            Unity_OneMinus_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float);
            float _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float = _FlowMapFlipGreen;
            float _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float;
            Unity_Lerp_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_G_5_Float, _OneMinus_daafb5be2f174d53a962c76e0f3d28b4_Out_1_Float, _Property_ae805b46fe85485999ebc2acbddc503f_Out_0_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float);
            float4 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4;
            float3 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            float2 _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2;
            Unity_Combine_float(_SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_R_4_Float, _Lerp_f9d3371a67a0404e9c5f69afaa234247_Out_3_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_B_6_Float, _SampleTexture2D_a8e3dad89cc64dca8a46080d5d51a0f1_A_7_Float, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGBA_4_Vector4, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3, _Combine_6cedd1b519464cb18fdd20a806d1b82f_RG_6_Vector2);
            float _Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float = _TransmittanceMultiplier;
            float4 _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4;
            Unity_Multiply_float4_float4(_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4, (_Property_826341eb7dda4b1ba1f4dfebcab836e3_Out_0_Float.xxxx), _Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4);
            float _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float = _RimTransmissionIntensity;
            float _Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float = _SpecularMultiplier;
            UnityTexture2D _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D = UnityBuildTexture2DStructNoScale(_SpecularMap);
            float4 _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4 = SAMPLE_TEXTURE2D(_Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.tex, UnityBuildSamplerStateStruct(SamplerState_Linear_Repeat).samplerstate, _Property_d2e83ab99d6c4bf48651e111f4c6e88b_Out_0_Texture2D.GetTransformedUV(IN.uv0.xy) );
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_R_4_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.r;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_G_5_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.g;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_B_6_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.b;
            float _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_A_7_Float = _SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4.a;
            float4 _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4 = _SpecularTint;
            float4 _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4;
            Unity_Multiply_float4_float4(_SampleTexture2D_a092fae44e0b454cb3b18c1769b66a72_RGBA_0_Vector4, _Property_f769abb9b5a74ec89369a250e2c8d39b_Out_0_Vector4, _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4);
            float4 _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4;
            Unity_Multiply_float4_float4((_Property_4be5e95fcd374b61bd561cf5a7bec49a_Out_0_Float.xxxx), _Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, _Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4);
            float _Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float = _SpecularShiftMin;
            float _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float = _SpecularShiftMax;
            float _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            Unity_Lerp_float(_Property_1012c39ced90447190bd2b2240698d4a_Out_0_Float, _Property_c8fd0f888a344933af6a199ebf6690d8_Out_0_Float, _SampleTexture2D_2c24de69dbf540b1be983740c589ab5a_G_5_Float, _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float);
            float _Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float = _SecondarySpecularMultiplier;
            float4 _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4;
            Unity_Multiply_float4_float4(_Multiply_815740e575684a18ae4f7aced285fb16_Out_2_Vector4, (_Property_7a473df09e9b4bd3b82814666640158f_Out_0_Float.xxxx), _Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4);
            float _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float = _SecondarySmoothness;
            float _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float = _SecondarySpecularShift;
            float _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            Unity_Add_float(_Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float, _Property_e00fd7cf1bf84eb8af3423a5f84f02da_Out_0_Float, _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float);
            surface.BaseColor = (_RLFunctionHairVertexColorBlend_7d9a2ad3d5ba4adb972e438f204c86ff_Color_1_Vector4.xyz);
            surface.Emission = (_Multiply_5245235678cb477da68d6fa9279e9ce2_Out_2_Vector4.xyz);
            surface.Alpha = _Maximum_ca13e965a3804f2fb7daa5db5687dc3b_Out_2_Float;
            surface.AlphaClipThreshold = _Property_20ec913f194d4acd871be539f0ceffd0_Out_0_Float;
            surface.AlphaClipThresholdDepthPrepass = _Property_6c82b6ddafb64673b5161a23abfc93e4_Out_0_Float;
            surface.AlphaClipThresholdDepthPostpass = _Property_72d4a986e38a498bae8f34613460f37e_Out_0_Float;
            surface.AlphaClipThresholdShadow = _Property_eba48f1e544d455986b250277b538909_Out_0_Float;
            surface.BentNormal = IN.TangentSpaceNormal;
            surface.Smoothness = _Lerp_8c8d7b4a3900435e88cf2280ae4ada94_Out_3_Float;
            surface.Occlusion = _Lerp_f38980ecc29541a9847b21e8026b9ed6_Out_3_Float;
            surface.NormalTS = _NormalStrength_c11ee2e3010d48a9a45e803c58cceaa3_Out_2_Vector3;
            surface.HairStrandDirection = _Combine_6cedd1b519464cb18fdd20a806d1b82f_RGB_5_Vector3;
            surface.Transmittance = (_Multiply_fedea005142540f88a5f899f708ab3b7_Out_2_Vector4.xyz);
            surface.RimTransmissionIntensity = _Property_627b5ab6400f4b94ae60bfcab74b4ab5_Out_0_Float;
            surface.SpecularTint = (_Multiply_1f325b3e26a640949036a22e6af17a00_Out_2_Vector4.xyz);
            surface.SpecularShift = _Lerp_891ed4660438493c8bca6c3b17265468_Out_3_Float;
            surface.SecondarySpecularTint = (_Multiply_366fe14bae29480a8d870a61047f38bf_Out_2_Vector4.xyz);
            surface.SecondarySmoothness = _Property_ed083dc9dc3c4f5fa9248d1b99d92da4_Out_0_Float;
            surface.SecondarySpecularShift = _Add_b67001a171c5448c94d2108c561f142e_Out_2_Float;
            return surface;
        }
        
            // --------------------------------------------------
            // Build Graph Inputs
            #ifdef HAVE_VFX_MODIFICATION
            #define VFX_SRP_ATTRIBUTES AttributesMesh
            #define VaryingsMeshType VaryingsMeshToPS
            #define VFX_SRP_VARYINGS VaryingsMeshType
            #define VFX_SRP_SURFACE_INPUTS FragInputs
            #endif
            SurfaceDescriptionInputs FragInputsToSurfaceDescriptionInputs(FragInputs input, float3 viewWS)
        {
            SurfaceDescriptionInputs output;
            ZERO_INITIALIZE(SurfaceDescriptionInputs, output);
        
            #if defined(SHADER_STAGE_RAY_TRACING)
            #else
            #endif
            output.TangentSpaceNormal =                         float3(0.0f, 0.0f, 1.0f);
        
        #if UNITY_UV_STARTS_AT_TOP
        #else
        #endif
        
        
            output.uv0 =                                        input.texCoord0;
        
            // splice point to copy frag inputs custom interpolator pack into the SDI
            /* WARNING: $splice Could not find named fragment 'CustomInterpolatorCopyToSDI' */
        
            return output;
        }
        
            // --------------------------------------------------
            // Build Surface Data (Specific Material)
        
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData);
        
        void ApplyDecalAndGetNormal(FragInputs fragInputs, PositionInputs posInput, SurfaceDescription surfaceDescription,
            inout SurfaceData surfaceData)
        {
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
        #ifdef DECAL_NORMAL_BLENDING
            // SG nodes don't ouptut surface gradients, so if decals require surf grad blending, we have to convert
            // the normal to gradient before applying the decal. We then have to resolve the gradient back to world space
            float3 normalTS;
        
            normalTS = SurfaceGradientFromTangentSpaceNormalAndFromTBN(surfaceDescription.NormalTS,
            fragInputs.tangentToWorld[0], fragInputs.tangentToWorld[1]);
        
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, fragInputs.tangentToWorld[2], normalTS);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        
            GetNormalWS_SG(fragInputs, normalTS, surfaceData.normalWS, doubleSidedConstants);
        #else
            // normal delivered to master node
            GetNormalWS(fragInputs, surfaceDescription.NormalTS, surfaceData.normalWS, doubleSidedConstants);
        
            #if HAVE_DECALS
            if (_EnableDecals)
            {
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Both uses and modifies 'surfaceData.normalWS'.
                DecalSurfaceData decalSurfaceData = GetDecalSurfaceData(posInput, fragInputs, alpha);
                ApplyDecalToSurfaceNormal(decalSurfaceData, surfaceData.normalWS.xyz);
                ApplyDecalToSurfaceDataNoNormal(decalSurfaceData, surfaceData);
            }
            #endif
        #endif
        }
        void ApplyDecalToSurfaceDataNoNormal(DecalSurfaceData decalSurfaceData, inout SurfaceData surfaceData)
        {
            // using alpha compositing https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch23.html
            surfaceData.diffuseColor.xyz = surfaceData.diffuseColor.xyz * decalSurfaceData.baseColor.w + decalSurfaceData.baseColor.xyz;
        
        #ifdef DECALS_4RT // only smoothness in 3RT mode
            // Don't apply any metallic modification
            surfaceData.ambientOcclusion = surfaceData.ambientOcclusion * decalSurfaceData.MAOSBlend.y + decalSurfaceData.mask.y;
        #endif
        
            surfaceData.perceptualSmoothness = surfaceData.perceptualSmoothness * decalSurfaceData.mask.w + decalSurfaceData.mask.z;
        }
        
        void BuildSurfaceData(FragInputs fragInputs, inout SurfaceDescription surfaceDescription, float3 V, PositionInputs posInput, out SurfaceData surfaceData, out float3 bentNormalWS)
        {
            // setup defaults -- these are used if the graph doesn't output a value
            ZERO_INITIALIZE(SurfaceData, surfaceData);
        
            // specularOcclusion need to be init ahead of decal to quiet the compiler that modify the SurfaceData struct
            // however specularOcclusion can come from the graph, so need to be init here so it can be override.
            surfaceData.specularOcclusion = 1.0;
        
            // copy across graph values, if defined
            surfaceData.diffuseColor =                   surfaceDescription.BaseColor;
        
        
        \
            surfaceData.perceptualSmoothness =           surfaceDescription.Smoothness;
            surfaceData.ambientOcclusion =               surfaceDescription.Occlusion;
            surfaceData.transmittance =                  surfaceDescription.Transmittance;
            surfaceData.rimTransmissionIntensity =       surfaceDescription.RimTransmissionIntensity;
        
            surfaceData.specularTint =                   surfaceDescription.SpecularTint;
            surfaceData.specularShift =                  surfaceDescription.SpecularShift;
        
            surfaceData.secondaryPerceptualSmoothness =  surfaceDescription.SecondarySmoothness;
            surfaceData.secondarySpecularTint =          surfaceDescription.SecondarySpecularTint;
            surfaceData.secondarySpecularShift =         surfaceDescription.SecondarySpecularShift;
        
        
        
            // These static material feature allow compile time optimization
            surfaceData.materialFeatures = 0;
        
            // Transform the preprocess macro into a material feature
            #ifdef _MATERIAL_FEATURE_HAIR_KAJIYA_KAY
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_KAJIYA_KAY;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER;
            #endif
        
            #ifdef _MATERIAL_FEATURE_HAIR_MARSCHNER_CINEMATIC
                surfaceData.materialFeatures |= MATERIALFEATUREFLAGS_HAIR_MARSCHNER_CINEMATIC;
            #endif
        
            float3 doubleSidedConstants = GetDoubleSidedConstants();
        
            ApplyDecalAndGetNormal(fragInputs, posInput, surfaceDescription, surfaceData);
        
            surfaceData.geomNormalWS = fragInputs.tangentToWorld[2];
        
            // For a typical Unity quad, you have tangent vectors pointing to the right (X axis),
            // and bitangent vectors pointing up (Y axis).
            // The current hair setup uses mesh cards (e.g. quads).
            // Hair is usually painted top-down, from the root to the tip.
            // Therefore, DefaultHairStrandTangent = -MeshCardBitangent.
            // Both the SurfaceData and the BSDFData store the hair tangent
            // (which represents the hair strand direction, root to tip).
            surfaceData.hairStrandDirectionWS = -fragInputs.tangentToWorld[1].xyz;
            // The hair strand direction texture contains tangent-space vectors.
            // We use the same convention for the texture, which means that
            // to get the default behavior (DefaultHairStrandTangent = -MeshCardBitangent),
            // the artist has to paint (0, -1, 0).
            // TODO: pending artist feedback...
            surfaceData.hairStrandDirectionWS = TransformTangentToWorld(surfaceDescription.HairStrandDirection, fragInputs.tangentToWorld);
            // The original Kajiya-Kay BRDF model expects an orthonormal TN frame.
            // Since we use the tangent shift hack (http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf),
            // we may as well not bother to orthonormalize anymore.
            // The tangent should still be a unit vector, though.
            surfaceData.hairStrandDirectionWS = normalize(surfaceData.hairStrandDirectionWS);
        
            // Small digression about hair and normals [NOTE-HAIR-NORMALS].
            // Since a hair strand is (approximately) a cylinder,
            // there is a whole "circle" of normals corresponding to any given tangent vector.
            // Since we use the Kajiya-Kay shading model,
            // the way we compute and use normals is a bit complicated.
            // We need 4 separate sets of normals.
            // For shadow bias, we use the geometric normal.
            // For direct lighting, we either (conceptually) use the "light-facing" normal
            // or the user-provided normal.
            // For reflected GI (light probes and reflection probes), we use the normal most aligned
            // with the view vector (the "view-facing" normal), or the user-provided normal.
            // We reflect this normal for transmitted GI.
            // For the highlight shift hack (along the tangent), we use the user-provided normal.
        
            #if (_USE_LIGHT_FACING_NORMAL)
                float3 viewFacingNormalWS = ComputeViewFacingNormal(V, surfaceData.hairStrandDirectionWS);
                float3 N = viewFacingNormalWS; // Not affected by decals
            #else
                float3 N = surfaceData.normalWS;
            #endif
        
            bentNormalWS = N;
        
        
            #ifdef DEBUG_DISPLAY
            #if !defined(SHADER_STAGE_RAY_TRACING)
                // Mipmap mode debugging isn't supported with ray tracing as it relies on derivatives
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    #ifdef FRAG_INPUTS_USE_TEXCOORD0
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG(posInput.positionSS, fragInputs.texCoord0);
                    #else
                        surfaceData.diffuseColor = GET_TEXTURE_STREAMING_DEBUG_NO_UV(posInput.positionSS);
                    #endif
                }
            #endif
        
                // We need to call ApplyDebugToSurfaceData after filling the surfarcedata and before filling builtinData
                // as it can modify attribute use for static lighting
                ApplyDebugToSurfaceData(fragInputs.tangentToWorld, surfaceData);
            #endif
        
            #if defined(_SPECULAR_OCCLUSION_CUSTOM)
                // Just use the value passed through via the slot (not active otherwise)
            #elif defined(_SPECULAR_OCCLUSION_FROM_AO_BENT_NORMAL)
                // If we have bent normal and ambient occlusion, process a specular occlusion
                surfaceData.specularOcclusion = GetSpecularOcclusionFromBentAO(V, bentNormalWS, N, surfaceData.ambientOcclusion, PerceptualSmoothnessToPerceptualRoughness(surfaceData.perceptualSmoothness));
            #elif defined(_AMBIENT_OCCLUSION) && defined(_SPECULAR_OCCLUSION_FROM_AO)
                surfaceData.specularOcclusion = GetSpecularOcclusionFromAmbientOcclusion(ClampNdotV(dot(N, V)), surfaceData.ambientOcclusion, PerceptualSmoothnessToRoughness(surfaceData.perceptualSmoothness));
            #endif
        
            #if defined(_ENABLE_GEOMETRIC_SPECULAR_AA) && !defined(SHADER_STAGE_RAY_TRACING)
                surfaceData.perceptualSmoothness = GeometricNormalFiltering(surfaceData.perceptualSmoothness, fragInputs.tangentToWorld[2], surfaceDescription.SpecularAAScreenSpaceVariance, surfaceDescription.SpecularAAThreshold);
            #endif
        }
        
            // --------------------------------------------------
            // Get Surface And BuiltinData
        
            void GetSurfaceAndBuiltinData(FragInputs fragInputs, float3 V, inout PositionInputs posInput, out SurfaceData surfaceData, out BuiltinData builtinData RAY_TRACING_OPTIONAL_PARAMETERS)
            {
                // Don't dither if displaced tessellation (we're fading out the displacement instead to match the next LOD)
                #if !defined(SHADER_STAGE_RAY_TRACING) && !defined(_TESSELLATION_DISPLACEMENT)
                #ifdef LOD_FADE_CROSSFADE // enable dithering LOD transition if user select CrossFade transition in LOD group
                LODDitheringTransition(ComputeFadeMaskSeed(V, posInput.positionSS), unity_LODFade.x);
                #endif
                #endif
        
                #ifndef SHADER_UNLIT
                #ifdef _DOUBLESIDED_ON
                    float3 doubleSidedConstants = _DoubleSidedConstants.xyz;
                #else
                    float3 doubleSidedConstants = float3(1.0, 1.0, 1.0);
                #endif
        
                ApplyDoubleSidedFlipOrMirror(fragInputs, doubleSidedConstants); // Apply double sided flip on the vertex normal
                #endif // SHADER_UNLIT
        
                SurfaceDescriptionInputs surfaceDescriptionInputs = FragInputsToSurfaceDescriptionInputs(fragInputs, V);
        
                #if defined(HAVE_VFX_MODIFICATION)
                GraphProperties properties;
                ZERO_INITIALIZE(GraphProperties, properties);
        
                GetElementPixelProperties(fragInputs, properties);
        
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs, properties);
                #else
                SurfaceDescription surfaceDescription = SurfaceDescriptionFunction(surfaceDescriptionInputs);
                #endif
        
                #ifdef DEBUG_DISPLAY
                if (_DebugMipMapMode != DEBUGMIPMAPMODE_NONE)
                {
                    surfaceDescription.Alpha = 1.0f;
                }
                #endif
        
                // Perform alpha test very early to save performance (a killed pixel will not sample textures)
                // TODO: split graph evaluation to grab just alpha dependencies first? tricky..
                #ifdef _ALPHATEST_ON
                    float alphaCutoff = surfaceDescription.AlphaClipThreshold;
                    #if SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_PREPASS
                    // The TransparentDepthPrepass is also used with SSR transparent.
                    // If an artists enable transaprent SSR but not the TransparentDepthPrepass itself, then we use AlphaClipThreshold
                    // otherwise if TransparentDepthPrepass is enabled we use AlphaClipThresholdDepthPrepass
                    #elif SHADERPASS == SHADERPASS_TRANSPARENT_DEPTH_POSTPASS
                    // DepthPostpass always use its own alpha threshold
                    alphaCutoff = surfaceDescription.AlphaClipThresholdDepthPostpass;
                    #elif (SHADERPASS == SHADERPASS_SHADOWS) || (SHADERPASS == SHADERPASS_RAYTRACING_VISIBILITY)
                    // If use shadow threshold isn't enable we don't allow any test
                    #endif
        
                    GENERIC_ALPHA_TEST(surfaceDescription.Alpha, alphaCutoff);
                #endif
        
                #if !defined(SHADER_STAGE_RAY_TRACING) && _DEPTHOFFSET_ON
                ApplyDepthOffsetPositionInput(V, surfaceDescription.DepthOffset, GetViewForwardDir(), GetWorldToHClipMatrix(), posInput);
                #endif
        
                #ifndef SHADER_UNLIT
                float3 bentNormalWS;
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData, bentNormalWS);
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD1
                    float4 lightmapTexCoord1 = fragInputs.texCoord1;
                #else
                    float4 lightmapTexCoord1 = float4(0,0,0,0);
                #endif
        
                #ifdef FRAG_INPUTS_USE_TEXCOORD2
                    float4 lightmapTexCoord2 = fragInputs.texCoord2;
                #else
                    float4 lightmapTexCoord2 = float4(0,0,0,0);
                #endif
        
                float alpha = 1.0;
                alpha = surfaceDescription.Alpha;
        
                // Builtin Data
                // For back lighting we use the oposite vertex normal
                InitBuiltinData(posInput, alpha, bentNormalWS, -fragInputs.tangentToWorld[2], lightmapTexCoord1, lightmapTexCoord2, builtinData);
        
                #else
                BuildSurfaceData(fragInputs, surfaceDescription, V, posInput, surfaceData);
        
                ZERO_BUILTIN_INITIALIZE(builtinData); // No call to InitBuiltinData as we don't have any lighting
                builtinData.opacity = surfaceDescription.Alpha;
        
                #if defined(DEBUG_DISPLAY)
                    // Light Layers are currently not used for the Unlit shader (because it is not lit)
                    // But Unlit objects do cast shadows according to their rendering layer mask, which is what we want to
                    // display in the light layers visualization mode, therefore we need the renderingLayers
                    builtinData.renderingLayers = GetMeshRenderingLayerMask();
                #endif
        
                #endif // SHADER_UNLIT
        
                #ifdef _ALPHATEST_ON
                    // Used for sharpening by alpha to mask - Alpha to covertage is only used with depth only and forward pass (no shadow pass, no transparent pass)
                    builtinData.alphaClipTreshold = alphaCutoff;
                #endif
        
                // override sampleBakedGI - not used by Unlit
        		// When overriding GI, we need to force the isLightmap flag to make sure we don't add APV (sampled in the lightloop) on top of the overridden value (set at GBuffer stage)
        
                builtinData.emissiveColor = surfaceDescription.Emission;
        
                // Note this will not fully work on transparent surfaces (can check with _SURFACE_TYPE_TRANSPARENT define)
                // We will always overwrite vt feeback with the nearest. So behind transparent surfaces vt will not be resolved
                // This is a limitation of the current MRT approach.
                #ifdef UNITY_VIRTUAL_TEXTURING
                #endif
        
                #if _DEPTHOFFSET_ON
                builtinData.depthOffset = surfaceDescription.DepthOffset;
                #endif
        
                // TODO: We should generate distortion / distortionBlur for non distortion pass
                #if (SHADERPASS == SHADERPASS_DISTORTION)
                builtinData.distortion = surfaceDescription.Distortion;
                builtinData.distortionBlur = surfaceDescription.DistortionBlur;
                #endif
        
                #ifndef SHADER_UNLIT
                // PostInitBuiltinData call ApplyDebugToBuiltinData
                PostInitBuiltinData(V, posInput, surfaceData, builtinData);
                #else
                ApplyDebugToBuiltinData(builtinData);
                #endif
        
                RAY_TRACING_OPTIONAL_ALPHA_TEST_PASS
            }
        
            // --------------------------------------------------
            // Main
        
            #include "Packages/com.unity.render-pipelines.high-definition/Runtime/RenderPipeline/ShaderPass/ShaderPassPathTracing.hlsl"
        
            // --------------------------------------------------
            // Visual Effect Vertex Invocations
        
        	#ifdef HAVE_VFX_MODIFICATION
                #if !defined(SHADER_STAGE_RAY_TRACING)
        	    #include "Packages/com.unity.render-pipelines.high-definition/Runtime/ShaderLibrary/VisualEffectVertex.hlsl"
                #else
                #endif
        	#endif
        
            ENDHLSL
        }
    }
    CustomEditor "UnityEditor.ShaderGraph.GenericShaderGraphMaterialGUI"
    CustomEditorForRenderPipeline "Rendering.HighDefinition.LightingShaderGraphGUI" "UnityEngine.Rendering.HighDefinition.HDRenderPipelineAsset"
    FallBack "Hidden/Shader Graph/FallbackError"
}